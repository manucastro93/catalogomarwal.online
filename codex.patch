diff --git a/.gitignore b/.gitignore
index 49c85158e4bd873683560bef94e867605edf76a3..8af6fd886f6014efbec6e877b875a6cd2c9f1fcf 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,26 +1,25 @@
 # Archivos de entorno
 .env
-.env.* 
+.env.*
 
 # Node
 node_modules/
 dist/
 build/
 
 # Logs
 *.log
 
 # Mac y sistema
 .DS_Store
 Thumbs.db
 
 # Vite
 .vite/
 
 # Configuraciones del sistema o editor
 .idea/
 .vscode/
 
 # Producción
 /public/uploads/
-backend-nest/
\ No newline at end of file
diff --git a/backend-nest/README.md b/backend-nest/README.md
new file mode 100644
index 0000000000000000000000000000000000000000..a569d780005c1d89e8400b0df27ca3b68c4dee02
--- /dev/null
+++ b/backend-nest/README.md
@@ -0,0 +1,11 @@
+# Backend NestJS
+
+Este directorio contiene una version inicial del backend utilizando [NestJS](https://nestjs.com/) con TypeScript. Sirve como punto de partida para 
migrar la logica de Express existente a una arquitectura basada en Nest.
+
+Para compilar y ejecutar en modo desarrollo se definen los siguientes comandos:
+
+```bash
+npm run start:dev
+```
+
+Recuerda instalar las dependencias con `npm install` antes de ejecutar los comandos.
diff --git a/backend-nest/package.json b/backend-nest/package.json
new file mode 100644
index 0000000000000000000000000000000000000000..e18d51bf44d79e82a2fc75479b092ba47ffacb29
--- /dev/null
+++ b/backend-nest/package.json
@@ -0,0 +1,23 @@
+{
+  "name": "backend-nest",
+  "version": "0.0.1",
+  "description": "NestJS backend conversion",
+  "private": true,
+  "scripts": {
+    "start": "node dist/main.js",
+    "build": "tsc -p tsconfig.build.json",
+    "start:dev": "ts-node-dev --respawn src/main.ts"
+  },
+  "dependencies": {
+    "@nestjs/common": "^10.0.0",
+    "@nestjs/core": "^10.0.0",
+    "@nestjs/platform-express": "^10.0.0",
+    "reflect-metadata": "^0.1.13",
+    "rxjs": "^7.8.1"
+  },
+  "devDependencies": {
+    "@types/node": "^20.0.0",
+    "ts-node-dev": "^2.0.0",
+    "typescript": "^5.4.0"
+  }
+}
diff --git a/backend-nest/src/app.controller.ts b/backend-nest/src/app.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..cce879ee622146012901c9adb47ef40c0fd3a555
--- /dev/null
+++ b/backend-nest/src/app.controller.ts
@@ -0,0 +1,12 @@
+import { Controller, Get } from '@nestjs/common';
+import { AppService } from './app.service';
+
+@Controller()
+export class AppController {
+  constructor(private readonly appService: AppService) {}
+
+  @Get()
+  getHello(): string {
+    return this.appService.getHello();
+  }
+}
diff --git a/backend-nest/src/app.module.ts b/backend-nest/src/app.module.ts
new file mode 100644
index 0000000000000000000000000000000000000000..86628031ca2a10fe172fe824f69d1720c44b43ce
--- /dev/null
+++ b/backend-nest/src/app.module.ts
@@ -0,0 +1,10 @@
+import { Module } from '@nestjs/common';
+import { AppController } from './app.controller';
+import { AppService } from './app.service';
+
+@Module({
+  imports: [],
+  controllers: [AppController],
+  providers: [AppService],
+})
+export class AppModule {}
diff --git a/backend-nest/src/app.service.ts b/backend-nest/src/app.service.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6206465917219890c7e7dbb6643d82446380008f
--- /dev/null
+++ b/backend-nest/src/app.service.ts
@@ -0,0 +1,8 @@
+import { Injectable } from '@nestjs/common';
+
+@Injectable()
+export class AppService {
+  getHello(): string {
+    return 'Hello from NestJS!';
+  }
+}
diff --git a/backend-nest/src/auth/auth.controller.ts b/backend-nest/src/auth/auth.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..2f1a22a3962c5a74cc65dd15e23a5c59dacbed54
--- /dev/null
+++ b/backend-nest/src/auth/auth.controller.ts
@@ -0,0 +1,60 @@
+import { Usuario, PermisosUsuario, Modulo, RolUsuario } from '@/models';
+import bcrypt from 'bcryptjs';
+import jwt from 'jsonwebtoken';
+
+export const login = async (req, res, next) => {
+  try {
+    const { email, contraseña } = req.body;
+    const usuario = await Usuario.findOne({ where: { email } });
+
+    if (!usuario) {
+      return res.status(401).json({ message: 'Credenciales inválidas' });
+    }
+
+    // Validar contraseña solo si tiene definida
+    if (usuario.contraseña) {
+      const coincide = await bcrypt.compare(contraseña, usuario.contraseña);
+      if (!coincide) {
+        return res.status(401).json({ message: 'Credenciales inválidas' });
+      }
+    }
+
+    // Obtener permisos del rol
+    const permisos = await PermisosUsuario.findAll({
+      where: { rolUsuarioId: usuario.rolUsuarioId, permitido: true },
+      include: [{ model: Modulo, as: 'modulo', attributes: ['nombre'] },
+                { model: RolUsuario, as: 'rolUsuario', attributes: ['nombre']   
+                }]
+    });
+
+    // Transformar permisos a formato plano para el frontend
+    const permisosPlano = permisos.map(p => ({
+      modulo: p.modulo?.nombre || '',
+      accion: p.accion,
+      permitido: p.permitido
+    }));
+
+    // Crear token
+    const token = jwt.sign(
+      {
+        id: usuario.id,
+        nombre: usuario.nombre,
+        email: usuario.email,
+        rolUsuarioId: usuario.rolUsuarioId
+      },
+      process.env.JWT_SECRET,
+      { expiresIn: '10000h' }
+    );
+
+    const usuarioLimpio = { ...usuario.toJSON(), permisos: permisosPlano };
+    delete usuarioLimpio.contraseña;
+
+    res.json({
+      token,
+      usuario: usuarioLimpio,
+      requiereContraseña: !usuario.contraseña
+    });
+  } catch (error) {
+    next(error);
+  }
+};
diff --git a/backend-nest/src/banner/banner.model.ts b/backend-nest/src/banner/banner.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..93ce826894418addf9911b664ba03075f3b37ca6
--- /dev/null
+++ b/backend-nest/src/banner/banner.model.ts
@@ -0,0 +1,33 @@
+export default (sequelize, DataTypes) => {
+  const Banner = sequelize.define('Banner', {
+    imagen: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    orden: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+    },
+    fechaInicio: {
+      type: DataTypes.DATE,
+      allowNull: true,
+    },
+    fechaFin: {
+      type: DataTypes.DATE,
+      allowNull: true,
+    },
+    paginaId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+    },
+  });
+
+  Banner.associate = (models) => {
+    Banner.belongsTo(models.Pagina, {
+      foreignKey: 'paginaId',
+      onDelete: 'CASCADE',
+    });
+  };
+
+  return Banner;
+};
diff --git a/backend-nest/src/bot/bot.controller.ts b/backend-nest/src/bot/bot.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9815423bc4e0bf418a2c535a5aef84560a5f641c
--- /dev/null
+++ b/backend-nest/src/bot/bot.controller.ts
@@ -0,0 +1,12 @@
+import { procesarMensaje } from '@/services/bot.service';
+
+export const recibirMensajeWhatsapp = async (req, res, next) => {
+  try {
+    const mensaje = req.body;
+    const respuesta = await procesarMensaje(mensaje);
+    res.status(200).json({ mensaje: 'Procesado correctamente', respuesta });
+  } catch (error) {
+    console.error('❌ Error al procesar mensaje de WhatsApp:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/categoria/categoria.controller.ts b/backend-nest/src/categoria/categoria.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..c127363f511d48def709ad1b1f03ea4a4c0f0091
--- /dev/null
+++ b/backend-nest/src/categoria/categoria.controller.ts
@@ -0,0 +1,171 @@
+import { Categoria } from '@/models';
+import Sequelize from 'sequelize';
+import cache from '@/utils/cache';
+import { crearAuditoria } from '@/utils/auditoria';
+
+export const listarCategorias = async (req, res) => {
+  try {
+    const { page = 1, limit = 10, buscar = '' } = req.query;
+    const offset = (page - 1) * limit;
+
+    const where = {};
+    if (buscar) {
+      where.nombre = { [Sequelize.Op.like]: `%${buscar}%` };
+    }
+
+    const { count, rows } = await Categoria.findAndCountAll({
+      where,
+      limit: Number(limit),
+      offset,
+      order: [['orden', 'ASC']],
+    });
+
+    const totalPaginas = Math.ceil(count / limit);
+    reson({
+      data: rows,
+      pagina: Number(page),
+      totalPaginas,
+      totalItems: count,
+      hasNextPage: Number(page) < totalPaginas,
+      hasPrevPage: Number(page) > 1,
+    });
+  } catch (error) {
+    console.error(error);
+    res.status(500)on({ message: 'Error al listar las categorías' });
+  }
+};
+
+export const crearCategoria = async (req, res) => {
+  try {
+    const { nombre, nombreWeb, orden, estado } = req.body;
+
+    const categoriaExistenteActiva = await Categoria.findOne({
+      where: { nombre, deletedAt: null },
+    });
+
+    if (categoriaExistenteActiva) {
+      return res.status(400)on({ message: `La categoría '${nombre}' ya existe y está activa` });
+    }
+
+    const categoriaExistenteEliminada = await Categoria.findOne({
+      where: { nombre },
+      paranoid: false,
+    });
+
+    if (categoriaExistenteEliminada) {
+      categoriaExistenteEliminada.estado = estado;
+      categoriaExistenteEliminada.orden = orden;
+      categoriaExistenteEliminada.nombreWeb = nombreWeb;
+      await categoriaExistenteEliminada.restore();
+      cache.del('categoriasPublicas');
+      return res.status(201)on({ message: 'Categoría restaurada correctamente', categoria: categoriaExistenteEliminada });
+    }
+
+    const nuevaCategoria = await Categoria.create({ nombre, nombreWeb, orden, estado });
+
+    await crearAuditoria({
+      tabla: 'categorias',
+      accion: 'crea categoria',
+      registroId: nuevaCategoria.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se creó la categoría ${nuevaCategoria.nombre}`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    cache.del('categoriasPublicas');
+    return res.status(201)on({ message: 'Categoría creada correctamente', categoria: nuevaCategoria });
+  } catch (error) {
+    console.error(error);
+    res.status(500)on({ message: 'Error al crear la categoría' });
+  }
+};
+
+export const editarCategoria = async (req, res) => {
+  try {
+    const { id } = req.params;
+    const { nombre, nombreWeb, orden, estado } = req.body;
+
+    const categoria = await Categoria.findByPk(id);
+    if (!categoria) {
+      return res.status(404)on({ message: 'Categoría no encontrada' });
+    }
+
+    const categoriaExistente = await Categoria.findOne({
+      where: { nombre, deletedAt: null },
+    });
+
+    const datosAntes = categoria.toJSON();
+
+    if (categoriaExistente && categoriaExistente.id !== categoria.id) {
+      return res.status(400)on({ message: `La categoría '${nombre}' ya existe y está activa` });
+    }
+
+    const categoriaEliminada = await Categoria.findOne({
+      where: { nombre },
+      paranoid: false,
+    });
+
+    if (categoriaEliminada && categoriaEliminada.id !== categoria.id) {
+      categoriaEliminada.estado = estado;
+      categoriaEliminada.orden = orden;
+      categoriaEliminada.nombreWeb = nombreWeb;
+      await categoriaEliminada.restore();
+      cache.del('categoriasPublicas');
+      return res.status(201)on({ message: 'Categoría restaurada correctamente', categoria: categoriaEliminada });
+    }
+
+    categoria.nombre = nombre;
+    categoria.nombreWeb = nombreWeb;
+    categoria.orden = orden;
+    categoria.estado = estado;
+    await categoria.save();
+    
+    const datosDespues = categoria.toJSON();
+
+    await crearAuditoria({
+      tabla: 'categorias',
+      accion: 'actualiza categoria',
+      registroId: categoria.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Categoria ${categoria.nombre} actualizada.`,
+      datosAntes,
+      datosDespues,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    cache.del('categoriasPublicas');
+    reson({ message: 'Categoría actualizada correctamente', categoria });
+  } catch (error) {
+    console.error(error);
+    res.status(500)on({ message: 'Error al actualizar la categoría' });
+  }
+};
+
+export const eliminarCategoria = async (req, res) => {
+  try {
+    const { id } = req.params;
+    const categoria = await Categoria.findByPk(id);
+
+    if (!categoria) {
+      return res.status(404)on({ message: 'Categoría no encontrada' });
+    }
+
+    await categoria.destroy();
+
+    await crearAuditoria({
+      tabla: 'categorias',
+      accion: 'elimina categoria',
+      registroId: categoria.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se eliminó la categoria "${categoria.nombre}"`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    cache.del('categoriasPublicas');
+
+    reson({ message: 'Categoría eliminada correctamente' });
+  } catch (error) {
+    console.error(error);
+    res.status(500)on({ message: 'Error al eliminar la categoría' });
+  }
+};
diff --git a/backend-nest/src/categoria/categoria.model.ts b/backend-nest/src/categoria/categoria.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..cfaeb54848924196dc79f40a5e8752e0862c1765
--- /dev/null
+++ b/backend-nest/src/categoria/categoria.model.ts
@@ -0,0 +1,57 @@
+export default (sequelize, DataTypes) => {
+  const Categoria = sequelize.define(
+    'Categoria',
+    {
+      id: {
+        type: DataTypes.INTEGER,
+        primaryKey: true,
+        autoIncrement: true,
+      },
+      nombre: {
+        type: DataTypes.STRING(255),
+        allowNull: false,
+      },
+      nombreWeb: {
+        type: DataTypes.STRING(200),
+        allowNull: false,
+      },
+      orden: {
+        type: DataTypes.INTEGER,
+        allowNull: true,
+      },
+      estado: {
+        type: DataTypes.BOOLEAN,
+        allowNull: true,
+        defaultValue: true,
+      },
+      createdAt: {
+        type: DataTypes.DATE,
+        allowNull: false,
+      },
+      updatedAt: {
+        type: DataTypes.DATE,
+        allowNull: false,
+      },
+      deletedAt: {
+        type: DataTypes.DATE,
+        allowNull: true,
+      },
+    },
+    {
+      sequelize,
+      modelName: 'Categoria',
+      tableName: 'Categorias',
+      timestamps: true,
+      paranoid: true,
+    }
+  );
+
+  Categoria.associate = (models) => {
+    Categoria.hasMany(models.Producto, {
+      foreignKey: 'categoriaId',
+      as: 'Productos',
+    });
+  };
+
+  return Categoria;
+};
diff --git a/backend-nest/src/chat/chat.controller.ts b/backend-nest/src/chat/chat.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..39583dbd00f91606ab3de92ee9338c73ac81add9
--- /dev/null
+++ b/backend-nest/src/chat/chat.controller.ts
@@ -0,0 +1,12 @@
+import { responderDesdeOpenAI } from '@/services/chat.service';
+
+export const responderPregunta = async (req, res) => {
+  try {
+    const { pregunta } = req.body;
+    const { respuesta, acciones } = await responderDesdeOpenAI(pregunta);
+    res.json({ respuesta, acciones });
+  } catch (error) {
+    console.error("❌ Error en chat.controller:", error);
+    res.status(500).json({ mensaje: "Error al responder la pregunta." });
+  }
+};
diff --git a/backend-nest/src/cliente/cliente.controller.ts b/backend-nest/src/cliente/cliente.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..665d57606d58c7e3e4a287bb276ae6e96127a82d
--- /dev/null
+++ b/backend-nest/src/cliente/cliente.controller.ts
@@ -0,0 +1,222 @@
+import { Cliente, Provincia, Localidad, Usuario, Pedido, DetallePedido, Producto, LogCliente, IpCliente, HistorialCliente, MensajeAutomatico } from 
'@/models';
+import { Op, fn, col, literal } from 'sequelize';
+import { validationResult } from 'express-validator';
+import { registrarHistorialCliente } from '@/utils/registrarHistorialCliente';
+import { crearAuditoria } from '@/utils/auditoria';
+import { crearClienteConGeocodificacion, actualizarClienteExistenteConGeocodificacion } from '@/helpers/clientes';
+
+export const listarClientes = async (req, res) => {
+  try {
+    const {
+      page = 1,
+      limit = 10,
+      orden = 'createdAt',
+      direccion = 'DESC',
+      buscar = '',
+      provinciaId,
+      localidadId,
+      vendedorId,
+    } = req.query;
+
+    const offset = (page - 1) * limit;
+    const where = {};
+
+    if (buscar) {
+      where[Op.or] = [
+        { nombre: { [Op.like]: `%${buscar}%` } },
+        { email: { [Op.like]: `%${buscar}%` } },
+      ];
+    }
+
+    if (req.usuario?.rol === 'vendedor') {
+      where.vendedorId = req.usuario.id;
+    }
+
+    if (provinciaId) where.provinciaId = provinciaId;
+    if (localidadId) where.localidadId = localidadId;
+    if (vendedorId) where.vendedorId = vendedorId;
+
+    const { count, rows } = await Cliente.findAndCountAll({
+      where,
+      limit: Number(limit),
+      offset,
+      order: [[orden, direccion]],
+      include: [
+        { model: Provincia, as: 'provincia' },
+        { model: Localidad, as: 'localidad' },
+        { model: Usuario, as: 'vendedor' },
+      ],
+    });
+
+    reson({
+      data: rows,
+      total: count,
+      pagina: Number(page),
+      totalPaginas: Math.ceil(count / limit),
+    });
+  } catch (err) {
+    console.error('❌ Error al listar clientes:', err);
+    res.status(500)on({ message: 'Error al obtener clientes' });
+  }
+};
+
+export const crearCliente = async (req, res) => {
+  try {
+    const errors = validationResult(req);
+    if (!errors.isEmpty()) {
+      return res.status(400)on({ errors: errors.array() });
+    }
+
+    const nuevoCliente = await crearClienteConGeocodificacion(req.body);
+    res.status(201)on(nuevoCliente);
+  } catch (error) {
+    console.error('❌ Error al crear cliente:', error);
+    res.status(500)on({ message: 'Error al crear cliente' });
+  }
+};
+
+export const actualizarCliente = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const clienteExistente = await Cliente.findByPk(id);
+    if (!clienteExistente) return res.status(404)on({ message: 'Cliente no encontrado' });
+
+    const actualizado = await actualizarClienteExistenteConGeocodificacion(clienteExistente, req.body, req.usuario?.id);
+
+    await registrarHistorialCliente(clienteExistente, actualizado, req.usuario?.id);
+
+    await crearAuditoria({
+      tabla: 'clientes',
+      accion: 'actualiza cliente',
+      registroId: actualizado.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Cliente ${actualizado.nombre} actualizado.`,
+      datosAntes: clienteExistente,
+      datosDespues: actualizado,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    reson(actualizado);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const obtenerClientesConVentas = async (req, res) => {
+  try {
+    const clientes = await Cliente.findAll({
+      include: [{ model: Pedido, as: 'pedidos', attributes: [], required: false }],
+      attributes: {
+        include: [[fn('SUM', col('pedidos.total')), 'totalVentas']],
+      },
+      group: ['Cliente.id'],
+    });
+    reson(clientes);
+  } catch (error) {
+    console.error(error);
+    res.status(500)on({ mensaje: 'Error al obtener clientes con ventas' });
+  }
+};
+
+export const obtenerEstadisticasCliente = async (req, res) => {
+  try {
+    const { id } = req.params;
+
+    // Total de pedidos y total facturado
+    const pedidos = await Pedido.findAll({
+      where: { clienteId: id },
+      attributes: ['id', 'total', 'createdAt'],
+      order: [['createdAt', 'DESC']],
+    });
+
+    // Productos más comprados
+    const productosTop = await DetallePedido.findAll({
+      where: { clienteId: id },
+      attributes: [
+        'productoId',
+        [fn('SUM', col('cantidad')), 'totalComprado'],
+        [fn('SUM', col('subtotal')), 'totalGastado'],
+      ],
+      include: [{ model: Producto, as: 'producto', attributes: ['nombre'] }],
+      group: ['productoId'],
+      order: [[literal('totalComprado'), 'DESC']],
+      limit: 5,
+    });
+
+    // Logs por IP
+    const ips = await IpCliente.findAll({ where: { clienteId: id }, attributes: ['id'] });
+    const ipIds = ips.map(ip => ip.id);
+
+    const logs = await LogCliente.findAll({
+      where: { ipClienteId: { [Op.in]: ipIds } },
+      order: [['createdAt', 'DESC']],
+    });
+
+    reson({ pedidos, productosTop, logs });
+  } catch (error) {
+    console.error("❌ Error en estadísticas de cliente:", error);
+    res.status(500)on({ message: 'Error al obtener estadísticas del cliente' });
+  }
+};
+
+export const obtenerHistorialCliente = async (req, res) => {
+  try {
+    const { id } = req.params;
+
+    const historial = await HistorialCliente.findAll({
+      where: { clienteId: id },
+      include: [{ model: Usuario, as: 'usuario', attributes: ['id', 'nombre'] }],
+      order: [['createdAt', 'DESC']],
+    });
+
+    reson(historial);
+  } catch (error) {
+    console.error('❌ Error al obtener historial del cliente:', error);
+    res.status(500)on({ message: 'Error al obtener historial del cliente' });
+  }
+};
+
+export const listarClientesInactivos = async (req, res) => {
+  try {
+    const tresMesesAtras = new Date();
+    tresMesesAtras.setMonth(tresMesesAtras.getMonth() - 3);
+
+    const clientes = await Cliente.findAll({
+      where: {
+        id: {
+          [Op.notIn]: literal(`(
+            SELECT DISTINCT clienteId FROM pedidos
+            WHERE createdAt >= '${tresMesesAtras.toISOString().slice(0, 19).replace('T', ' ')}'
+          )`)
+        }
+      },
+      include: [
+        { model: Provincia, as: 'provincia' },
+        { model: Localidad, as: 'localidad' },
+        { model: Usuario, as: 'vendedor' },
+      ],
+      order: [['createdAt', 'DESC']]
+    });
+
+    reson({ data: clientes, total: clientes.length });
+  } catch (error) {
+    console.error('❌ Error al listar clientes inactivos:', error);
+    res.status(500)on({ message: 'Error al listar clientes inactivos' });
+  }
+};
+
+export const obtenerSeguimientoCliente = async (req, res) => {
+  try {
+    const clienteId = req.params.id;
+
+    const mensajes = await MensajeAutomatico.findAll({
+      where: { clienteId },
+      order: [['fechaEnvio', 'ASC']]
+    });
+
+    reson({ data: mensajes });
+  } catch (error) {
+    console.error('Error al obtener seguimiento del cliente:', error);
+    res.status(500)on({ mensaje: 'Error al obtener seguimiento del cliente' });
+  }
+};
diff --git a/backend-nest/src/cliente/cliente.model.ts b/backend-nest/src/cliente/cliente.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..480385d86596d0093a0e97895b8b601fcdefcb14
--- /dev/null
+++ b/backend-nest/src/cliente/cliente.model.ts
@@ -0,0 +1,64 @@
+export default (sequelize, DataTypes) => {
+  const Cliente = sequelize.define('Cliente', {
+    nombre: DataTypes.STRING,
+    email: DataTypes.STRING,
+    telefono: DataTypes.STRING,
+    direccion: DataTypes.STRING,
+    razonSocial: DataTypes.STRING,
+    cuit_cuil: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    transporte: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    provinciaId: {
+      type: DataTypes.INTEGER,
+      references: { model: 'Provincias', key: 'id' },
+    },
+    localidadId: {
+      type: DataTypes.INTEGER,
+      references: { model: 'Localidades', key: 'id' },
+    },
+    vendedorId: DataTypes.INTEGER,
+    latitud: DataTypes.DOUBLE,
+    longitud: DataTypes.DOUBLE,
+    seguimiento: {
+      type: DataTypes.BOOLEAN,
+      allowNull: false,
+      defaultValue: true
+    }
+  }, {
+    tableName: 'Clientes',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  Cliente.associate = (models) => {
+    Cliente.belongsTo(models.Provincia, {
+      foreignKey: 'provinciaId',
+      as: 'provincia',
+    });
+    Cliente.belongsTo(models.Localidad, {
+      foreignKey: 'localidadId',
+      as: 'localidad',
+    });
+    Cliente.belongsTo(models.Usuario, {
+      foreignKey: 'vendedorId',
+      as: 'vendedor',
+    });
+    Cliente.hasMany(models.Pedido, {
+      foreignKey: 'clienteId',
+      as: 'pedidos',
+    });
+    Cliente.belongsToMany(models.IpCliente, {
+      through: models.IpClienteCliente,
+      foreignKey: 'clienteId',
+      otherKey: 'ipClienteId',
+      as: 'ips',
+    });
+  };
+
+  return Cliente;
+};
diff --git a/backend-nest/src/conversacionbot/conversacionbot.controller.ts b/backend-nest/src/conversacionbot/conversacionbot.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ddc765cf2065740e0826319a73d739b2081bc561
--- /dev/null
+++ b/backend-nest/src/conversacionbot/conversacionbot.controller.ts
@@ -0,0 +1,178 @@
+import { ConversacionBot, Cliente } from '@/models';
+import { Op, Sequelize } from 'sequelize';
+import { enviarMensajeTextoLibreWhatsapp } from '@/helpers/enviarMensajeWhatsapp';
+
+function normalizarTelefono(numero) {
+  if (!numero) return '';
+  return numero
+    .replace(/\D/g, '')
+    .replace(/^54911/, '011')
+    .replace(/^5411/, '011')
+    .replace(/^11/, '011')
+    .replace(/^0+/, '');
+}
+
+// GET /conversaciones
+export const listarConversacionesBot = async (req, res, next) => {
+  try {
+    const { page = 1, limit = 20, buscar = '', derivar = '' } = req.query;
+    const offset = (page - 1) * limit;
+    const where = {};
+
+    if (buscar) {
+      where[Op.or] = [
+        { telefono: { [Op.like]: `%${buscar}%` } },
+        { mensajeCliente: { [Op.like]: `%${buscar}%` } },
+        { respuestaBot: { [Op.like]: `%${buscar}%` } },
+      ];
+    }
+
+    if (derivar !== '') {
+      where.derivar = derivar === 'true';
+    }
+
+    const { count, rows } = await ConversacionBot.findAndCountAll({
+      where,
+      order: [['createdAt', 'DESC']],
+      limit: Number(limit),
+      offset,
+    });
+
+    res.json({
+      data: rows,
+      pagina: Number(page),
+      totalPaginas: Math.ceil(count / limit),
+      totalItems: count,
+      hasNextPage: Number(page) < Math.ceil(count / limit),
+      hasPrevPage: Number(page) > 1,
+    });
+  } catch (error) {
+    console.error('❌ Error al listar conversaciones:', error);
+    next(error);
+  }
+};
+
+// GET /conversaciones/ultimas
+export const listarUltimasConversacionesPorCliente = async (req, res, next) => {
+  try {
+    const conversaciones = await ConversacionBot.findAll({
+      attributes: [
+        'telefono',
+        [Sequelize.fn('MAX', Sequelize.col('createdAt')), 'ultimoMensaje'],
+      ],
+      group: ['telefono'],
+      order: [[Sequelize.fn('MAX', Sequelize.col('createdAt')), 'DESC']],
+    });
+
+    const clientes = await Cliente.findAll();
+
+    const resultado = conversaciones.map(conv => {
+      const cliente = clientes.find(c =>
+        normalizarTelefono(c.telefono) === normalizarTelefono(conv.telefono)
+      );
+      return {
+        telefono: conv.telefono,
+        ultimoMensaje: conv.dataValues.ultimoMensaje,
+        cliente: cliente
+          ? { nombre: cliente.nombre || cliente.razonSocial || cliente.email }
+          : null
+      };
+    });
+
+    res.json(resultado);
+  } catch (error) {
+    console.error('❌ Error al listar últimos mensajes por cliente:', error);
+    next(error);
+  }
+};
+
+// GET /conversaciones/agrupadas
+export const listarConversacionesAgrupadas = async (req, res, next) => {
+  try {
+    const { buscar = '' } = req.query;
+    const where = {};
+
+    if (buscar) {
+      where.telefono = { [Op.like]: `%${buscar}%` };
+    }
+
+    const conversaciones = await ConversacionBot.findAll({
+      where,
+      order: [['telefono', 'ASC'], ['createdAt', 'ASC']],
+    });
+
+    const clientes = await Cliente.findAll();
+    const agrupadas = {};
+
+    for (const conv of conversaciones) {
+      const tel = conv.telefono;
+      const telNorm = normalizarTelefono(tel);
+
+      if (!agrupadas[tel]) {
+        const cliente = clientes.find(c =>
+          normalizarTelefono(c.telefono) === telNorm
+        );
+
+        agrupadas[tel] = {
+          telefono: tel,
+          cliente: cliente
+            ? { nombre: cliente.nombre || cliente.razonSocial || cliente.email }
+            : undefined,
+          historial: []
+        };
+      }
+
+      agrupadas[tel].historial.push({
+        mensajeCliente: conv.mensajeCliente,
+        respuestaBot: conv.respuestaBot,
+        derivar: conv.derivar,
+        createdAt: conv.createdAt,
+      });
+    }
+
+    res.json({ data: Object.values(agrupadas) });
+
+  } catch (error) {
+    console.error('❌ Error al agrupar conversaciones:', error);
+    next(error);
+  }
+};
+
+// POST /conversaciones/responder
+export const responderManual = async (req, res, next) => {
+  try {
+    const { telefono, mensaje } = req.body;
+    if (!telefono || !mensaje) {
+      return res.status(400).json({ error: 'Faltan datos' });
+    }
+
+    const telefonoNormalizado = normalizarTelefono(telefono);
+    const clientes = await Cliente.findAll();
+
+    const cliente = clientes.find(c =>
+      normalizarTelefono(c.telefono) === telefonoNormalizado
+    );
+
+    const conversacion = await ConversacionBot.create({
+      telefono,
+      mensajeCliente: '',
+      respuestaBot: mensaje,
+      derivar: false,
+      intervencionManual: true,
+      clienteId: cliente?.id || null,
+    });
+
+    if (cliente) {
+      console.log(`✅ Se respondió a un cliente: ${cliente.nombre || cliente.razonSocial || cliente.email}`);
+    } else {
+      console.log('ℹ️ Número no corresponde a ningún cliente registrado.');
+    }
+
+    await enviarMensajeTextoLibreWhatsapp(telefono, mensaje);
+
+    res.json({ ok: true, conversacion, esCliente: !!cliente });
+  } catch (err) {
+    console.error('❌ Error al guardar respuesta manual:', err);
+    next(err);
+  }
+};
diff --git a/backend-nest/src/conversacionbot/conversacionbot.model.ts b/backend-nest/src/conversacionbot/conversacionbot.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1378d3408389eab6b109724b806658deae89727a
--- /dev/null
+++ b/backend-nest/src/conversacionbot/conversacionbot.model.ts
@@ -0,0 +1,38 @@
+export default (sequelize, DataTypes) => {
+  const ConversacionBot = sequelize.define('ConversacionBot', {
+    telefono: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    mensajeCliente: {
+      type: DataTypes.TEXT,
+      allowNull: false,
+    },
+    respuestaBot: {
+      type: DataTypes.TEXT,
+      allowNull: false,
+    },
+    derivar: {
+      type: DataTypes.BOOLEAN,
+      defaultValue: false,
+    },
+    clienteId: {
+    type: DataTypes.INTEGER,
+    allowNull: true,
+  },
+    intervencionManual: {
+    type: DataTypes.BOOLEAN,
+    defaultValue: false,
+  }
+  }, {
+    tableName: 'ConversacionesBot',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  ConversacionBot.associate = (models) => {
+    ConversacionBot.belongsTo(models.Cliente, { foreignKey: 'clienteId', as: 'cliente' });
+  };
+
+  return ConversacionBot;
+};
diff --git a/backend-nest/src/detallefactura/detallefactura.model.ts b/backend-nest/src/detallefactura/detallefactura.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..362dae24936938c8439fd68a7b5ebf9c962d2f09
--- /dev/null
+++ b/backend-nest/src/detallefactura/detallefactura.model.ts
@@ -0,0 +1,58 @@
+export default (sequelize, DataTypes) => {
+  const DetalleFactura = sequelize.define(
+    'DetalleFactura',
+    {
+      cantidad: {
+        type: DataTypes.FLOAT,
+        allowNull: false,
+      },
+      precioUnitario: {
+        type: DataTypes.FLOAT,
+        allowNull: false,
+      },
+      subtotal: {
+        type: DataTypes.FLOAT,
+        allowNull: false,
+        defaultValue: 0,
+      },
+      descuento: {
+        type: DataTypes.FLOAT,
+        allowNull: true,
+      },
+      costo: {
+        type: DataTypes.FLOAT,
+        allowNull: true,
+      },
+      codItem: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+      descripcion: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+      facturaId: {
+        type: DataTypes.BIGINT,
+        allowNull: false,
+        references: {
+          model: 'Facturas',
+          key: 'id',
+        },
+      },
+    },
+    {
+      tableName: 'DetalleFacturas',
+      timestamps: false,
+      paranoid: false
+    }
+  );
+
+  DetalleFactura.associate = (models) => {
+    DetalleFactura.belongsTo(models.Factura, {
+      foreignKey: 'facturaId',
+      as: 'factura',
+    });
+  };
+
+  return DetalleFactura;
+};
diff --git a/backend-nest/src/detallepedido/detallepedido.model.ts b/backend-nest/src/detallepedido/detallepedido.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..2665211d0b40fb45f040beaded8a5aed38764f76
--- /dev/null
+++ b/backend-nest/src/detallepedido/detallepedido.model.ts
@@ -0,0 +1,78 @@
+export default (sequelize, DataTypes) => {
+  const DetallePedido = sequelize.define('DetallePedido', {
+    cantidad: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+    },
+    precioUnitario: {
+      type: DataTypes.FLOAT,
+      allowNull: false,
+    },
+    unidadPorBulto: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    },
+    precioPorBulto: {
+      type: DataTypes.FLOAT,
+      allowNull: true,
+    },
+    subtotal: {
+      type: DataTypes.FLOAT,
+      allowNull: false,
+      defaultValue: 0,
+    },
+    descuento: {
+      type: DataTypes.FLOAT,
+      allowNull: true,
+    },
+    observaciones: {
+      type: DataTypes.TEXT,
+      allowNull: true,
+    },
+    dispositivo: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    pedidoId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Pedidos',
+        key: 'id',
+      },
+    },
+    productoId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Productos',
+        key: 'id',
+      },
+    },
+    clienteId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Clientes',
+        key: 'id',
+      },
+    },
+    usuarioId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+      references: {
+        model: 'Usuarios',
+        key: 'id',
+      },
+    },
+  });
+
+  DetallePedido.associate = (models) => {
+    DetallePedido.belongsTo(models.Pedido, { foreignKey: 'pedidoId', as: 'pedido' });
+    DetallePedido.belongsTo(models.Producto, { foreignKey: 'productoId', as: 'producto' });
+    DetallePedido.belongsTo(models.Cliente, { foreignKey: 'clienteId', as: 'cliente' });
+    DetallePedido.belongsTo(models.Usuario, { foreignKey: 'usuarioId', as: 'usuario' });
+  };
+
+  return DetallePedido;
+};
diff --git a/backend-nest/src/detallepedidodux/detallepedidodux.model.ts b/backend-nest/src/detallepedidodux/detallepedidodux.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e62155ccae7041f8d9d6c3cb128bc242804db762
--- /dev/null
+++ b/backend-nest/src/detallepedidodux/detallepedidodux.model.ts
@@ -0,0 +1,54 @@
+export default (sequelize, DataTypes) => {
+  const DetallePedidoDux = sequelize.define(
+    'DetallePedidoDux',
+    {
+      cantidad: {
+        type: DataTypes.FLOAT,
+        allowNull: false,
+      },
+      precioUnitario: {
+        type: DataTypes.FLOAT,
+        allowNull: false,
+      },
+      subtotal: {
+        type: DataTypes.FLOAT,
+        allowNull: false,
+        defaultValue: 0,
+      },
+      descuento: {
+        type: DataTypes.FLOAT,
+        allowNull: true,
+      },
+      codItem: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+      descripcion: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+      pedidoDuxId: {
+        type: DataTypes.INTEGER,
+        allowNull: false,
+        references: {
+          model: 'PedidosDux',
+          key: 'id',
+        },
+      },
+    },
+    {
+      tableName: 'DetallePedidosDux',
+      timestamps: false,
+      paranoid: false
+    }
+  );
+
+  DetallePedidoDux.associate = (models) => {
+    DetallePedidoDux.belongsTo(models.PedidoDux, {
+      foreignKey: 'pedidoDuxId',
+      as: 'pedidoDux',
+    });
+  };
+
+  return DetallePedidoDux;
+};
diff --git a/backend-nest/src/dux/dux.controller.ts b/backend-nest/src/dux/dux.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5c45756347a6fc741819bc998331542b01deb309
--- /dev/null
+++ b/backend-nest/src/dux/dux.controller.ts
@@ -0,0 +1,63 @@
+import axios from 'axios';
+import { sincronizarProductosDesdeDux } from '@/services/dux.service';
+import { estadoSync } from '@/state/estadoSync';
+
+export const sincronizarDesdeDuxController = async (req, res) => {
+  try {
+    const resultado = await sincronizarProductosDesdeDux();
+    res.status(200).json({ ok: true, ...resultado });
+  } catch (error) {
+    console.error('❌ Error al sincronizar productos desde Dux:', error);
+    res.status(500).json({ ok: false, mensaje: error.message });
+  }
+};
+
+export const getProgresoSync = (req, res) => {
+  try {
+    console.log('➡️ Progreso actual:', estadoSync.porcentaje);
+    res.json({ porcentaje: estadoSync.porcentaje });
+  } catch (error) {
+    console.error('❌ Error al obtener progreso:', error);
+    res.status(500).json({ porcentaje: 0 });
+  }
+};
+
+let cacheDux = null;
+let cacheTimestamp = 0;
+
+export const obtenerPedidosDux = async (req, res) => {
+  const ahora = Date.now();
+  const TTL = 5000;
+
+  if (cacheDux && ahora - cacheTimestamp < TTL) {
+    return res.json(cacheDux);
+  }
+
+  try {
+    const response = await axios.get('https://erp.duxsoftware.com.ar/WSERP/rest/services/pedidos', {
+      headers: {
+        accept: 'application/json',
+        authorization: process.env.DUX_API_KEY,
+      },
+      params: {
+        idEmpresa: 5627,
+        idSucursal: 1,
+        fechaDesde: '2020-01-01',
+        fechaHasta: '2025-11-30',
+      },
+    });
+
+    const dataConTipo = response.data.results.map(p => ({
+      ...p,
+      tipo: 'dux',
+    }));
+
+    cacheDux = { data: dataConTipo };
+    cacheTimestamp = ahora;
+
+    return res.json(cacheDux);
+  } catch (error) {
+    console.error('❌ Error al obtener pedidos Dux:', error.message);
+    return res.status(500).json({ error: 'Error al obtener pedidos Dux' });
+  }
+};
diff --git a/backend-nest/src/eficiencia/eficiencia.controller.ts b/backend-nest/src/eficiencia/eficiencia.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6b4e6624882a2c46f1050386ed312181b006f316
--- /dev/null
+++ b/backend-nest/src/eficiencia/eficiencia.controller.ts
@@ -0,0 +1,1182 @@
+import { Op, fn, col, where } from 'sequelize';
+import dayjs from 'dayjs';
+import { Factura, PedidoDux, DetalleFactura, DetallePedidoDux, Producto, Categoria } from "@/models";
+import { generarResumenEjecutivo } from '@/services/eficiencia.service';
+
+export const obtenerResumenEficiencia = async (req, res) => {
+  try {
+    const { desde, hasta } = req.query;
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Faltan parámetros 'desde' y 'hasta'" });
+    }
+
+    const resumen = await generarResumenEjecutivo(new Date(desde), new Date(hasta));
+    res.json(resumen);
+  } catch (err) {
+    console.error("❌ Error en obtenerResumenEficiencia:", err);
+    res.status(500).json({ error: "Error al calcular resumen ejecutivo" });
+  }
+};
+
+export const obtenerEvolucionEficiencia = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    const pedidos = await PedidoDux.findAll({
+      where: {
+        fecha: { [Op.between]: [desde, hasta] },
+      }
+    });
+
+    const facturas = await Factura.findAll({
+      where: {
+        fecha_comp: { [Op.between]: [desde, hasta] },
+        anulada_boolean: false,
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        }
+      }
+    });
+
+    const pedidosMap = new Map(pedidos.map(p => [p.nro_pedido, p]));
+
+    const porFecha = {};
+
+    for (const factura of facturas) {
+      const fechaStr = dayjs(factura.fecha_comp).format("YYYY-MM-DD");
+      const pedido = pedidosMap.get(factura.nro_pedido);
+
+      if (!pedido) continue;
+
+      const dias = Math.round((new Date(factura.fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24));
+
+      if (!porFecha[fechaStr]) {
+        porFecha[fechaStr] = { totalLeadTime: 0, count: 0 };
+      }
+
+      porFecha[fechaStr].totalLeadTime += dias;
+      porFecha[fechaStr].count += 1;
+    }
+
+    const resultado = Object.entries(porFecha).map(([fecha, valores]) => ({
+      fecha,
+      leadTime: +(valores.totalLeadTime / valores.count).toFixed(2)
+    }));
+
+    res.json(resultado);
+  } catch (error) {
+    console.error("Error en obtenerEvolucionEficiencia:", error);
+    res.status(500).json({ error: "Error al calcular evolución" });
+  }
+};
+
+export const obtenerEvolucionFillRate = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        where: {
+          fecha: { [Op.between]: [desde, hasta] },
+        },
+        attributes: ["fecha"],
+      },
+    });
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false,
+        },
+        attributes: ["fecha_comp"],
+      },
+    });
+
+    const pedidosPorFecha = {};
+    const facturasPorFecha = {};
+
+    for (const d of detallesPedidos) {
+      const fechaStr = dayjs(d.pedidoDux.fecha).format("YYYY-MM-DD");
+      if (!pedidosPorFecha[fechaStr]) pedidosPorFecha[fechaStr] = 0;
+      pedidosPorFecha[fechaStr] += parseFloat(d.cantidad || 0);
+    }
+
+    for (const d of detallesFacturas) {
+      const fechaStr = dayjs(d.factura.fecha_comp).format("YYYY-MM-DD");
+      if (!facturasPorFecha[fechaStr]) facturasPorFecha[fechaStr] = 0;
+      facturasPorFecha[fechaStr] += parseFloat(d.cantidad || 0);
+    }
+
+    const fechas = Array.from(new Set([...Object.keys(pedidosPorFecha), ...Object.keys(facturasPorFecha)])).sort();
+
+    const resultado = fechas.map((fecha) => {
+      const pedida = pedidosPorFecha[fecha] || 0;
+      const facturada = facturasPorFecha[fecha] || 0;
+      const porcentaje = pedida > 0 ? +(Math.min(facturada / pedida, 1) * 100).toFixed(2) : 0;
+      return { fecha, fillRate: porcentaje };
+    });
+
+    res.json(resultado);
+  } catch (error) {
+    console.error("Error en obtenerEvolucionFillRate:", error);
+    res.status(500).json({ error: "Error al calcular evolución de fill rate" });
+  }
+};
+
+export const obtenerOutliersFillRate = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        where: {
+          fecha: { [Op.between]: [desde, hasta] },
+        },
+        attributes: []
+      }
+    });
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false
+        },
+        attributes: []
+      }
+    });
+
+    const pedidosPorItem = {};
+    const nombresPorItem = {};
+    const facturasPorItem = {};
+
+    for (const d of detallesPedidos) {
+      const key = d.codItem;
+      pedidosPorItem[key] = (pedidosPorItem[key] || 0) + parseFloat(d.cantidad || 0);
+      nombresPorItem[key] = d.descripcion || key;
+    }
+
+    for (const d of detallesFacturas) {
+      const key = d.codItem;
+      facturasPorItem[key] = (facturasPorItem[key] || 0) + parseFloat(d.cantidad || 0);
+    }
+
+    const outliers = [];
+
+    for (const key in pedidosPorItem) {
+      const pedidas = pedidosPorItem[key];
+      const facturadas = facturasPorItem[key] || 0;
+      const porcentaje = pedidas > 0 ? (facturadas / pedidas) * 100 : 0;
+      outliers.push({
+        codItem: key,
+        descripcion: nombresPorItem[key],
+        pedidas: Math.round(pedidas),
+        facturadas: Math.round(facturadas),
+        fillRate: +porcentaje.toFixed(2)
+      });
+    }
+
+    outliers.sort((a, b) => a.fillRate - b.fillRate); // peor primero
+    res.json(outliers.slice(0, 20)); // top 20 peores
+  } catch (error) {
+    console.error("Error en obtenerOutliersFillRate:", error);
+    res.status(500).json({ error: "Error al obtener productos con bajo fill rate" });
+  }
+};
+
+export const obtenerEvolucionEficienciaMensual = async (req, res) => {
+  try {
+    const desde = "2015-01-01";
+    const hasta = new Date();
+    const cliente = req.query.cliente?.toLowerCase();
+
+    if (!hasta) return res.status(400).json({ error: "Parámetro 'hasta' requerido" });
+
+    // 1. Pedidos (filtrados por cliente si aplica)
+    const wherePedidos = {
+      fecha: { [Op.between]: [desde, hasta] },
+      ...(cliente ? { cliente: { [Op.like]: `%${cliente}%` } } : {})
+    };
+
+    const pedidos = await PedidoDux.findAll({
+      where: wherePedidos,
+      attributes: ["id", "fecha", "nro_pedido"],
+    });
+
+    const idPedidos = pedidos.map(p => p.id);
+    const nroPedidos = pedidos.map(p => p.nro_pedido);
+    const pedidosPorNro = new Map(pedidos.map(p => [p.nro_pedido, p]));
+
+    // 2. Detalles de pedidos
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      where: { pedidoDuxId: { [Op.in]: idPedidos } },
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        attributes: ["fecha"]
+      }
+    });
+
+    // 3. Facturas válidas relacionadas a los pedidos
+    const facturas = await Factura.findAll({
+      where: {
+        fecha_comp: { [Op.between]: [desde, hasta] },
+        anulada_boolean: false,
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        },
+        nro_pedido: { [Op.in]: nroPedidos },
+      },
+      attributes: ["nro_pedido", "fecha_comp"],
+    });
+
+    const facturasPorNro = new Map(facturas.map(f => [f.nro_pedido, f]));
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false,
+          tipo_comp: {
+            [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+          },
+          nro_pedido: { [Op.in]: nroPedidos }
+        },
+        attributes: ["fecha_comp", "nro_pedido"]
+      }
+    });
+
+    // 4. Acumuladores
+    const dataPorMes = {};
+
+    for (const d of detallesPedidos) {
+      const mes = dayjs(d.pedidoDux.fecha).format("YYYY-MM");
+      dataPorMes[mes] = dataPorMes[mes] || { pedida: 0, facturada: 0, totalLeadTime: 0, countLeadTime: 0 };
+      dataPorMes[mes].pedida += parseFloat(d.cantidad || "0");
+    }
+
+    for (const d of detallesFacturas) {
+      const nro = d.factura.nro_pedido;
+      const factura = d.factura;
+      const pedido = pedidosPorNro.get(nro);
+      if (!pedido) continue;
+
+      const mes = dayjs(factura.fecha_comp).format("YYYY-MM");
+
+      dataPorMes[mes] = dataPorMes[mes] || { pedida: 0, facturada: 0, totalLeadTime: 0, countLeadTime: 0 };
+      dataPorMes[mes].facturada += parseFloat(d.cantidad || "0");
+
+      const dias = Math.max(0, Math.round((new Date(factura.fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24)));
+      dataPorMes[mes].totalLeadTime += dias;
+      dataPorMes[mes].countLeadTime += 1;
+    }
+    
+    const resultado = Object.entries(dataPorMes)
+      .sort(([a], [b]) => a.localeCompare(b))
+      .map(([mes, v]) => ({
+        mes,
+        fillRate: v.pedida > 0 ? +(Math.min(v.facturada / v.pedida, 1) * 100).toFixed(2) : 0,
+        leadTime: v.countLeadTime > 0 ? +(v.totalLeadTime / v.countLeadTime).toFixed(2) : null
+      }));
+
+    res.json(resultado);
+  } catch (error) {
+    console.error("Error en obtenerEvolucionEficienciaMensual:", error);
+    res.status(500).json({ error: "Error al calcular eficiencia mensual" });
+  }
+};
+
+export const obtenerEficienciaPorPedido = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    const pedidos = await PedidoDux.findAll({
+      where: {
+        fecha: { [Op.between]: [desde, hasta] }
+      },
+      attributes: ['id', 'nro_pedido', 'fecha']
+    });
+
+    const nroPedidos = pedidos.map(p => p.nro_pedido);
+
+    const facturas = await Factura.findAll({
+      where: {
+        nro_pedido: { [Op.in]: nroPedidos },
+        anulada_boolean: false,
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        }
+      },
+      attributes: ['nro_pedido', 'fecha_comp']
+    });
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+  where: {
+    pedidoDuxId: { [Op.in]: pedidos.map(p => p.id) }
+  }
+});
+
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: [{
+        model: Factura,
+        as: 'factura',
+        where: {
+          nro_pedido: { [Op.in]: nroPedidos },
+          anulada_boolean: false
+        },
+        attributes: ['nro_pedido']
+      }]
+    });
+
+    const facturasMap = new Map(facturas.map(f => [f.nro_pedido, f]));
+
+    const resultado = pedidos.map(pedido => {
+      const facturasDelPedido = facturas.filter(f => f.nro_pedido === pedido.nro_pedido);
+
+      const detallesP = detallesPedidos.filter(d => d.pedidoDuxId === pedido.id);
+      const cantidadPedida = detallesP.reduce((acc, d) => acc + parseFloat(d.cantidad || 0), 0);
+
+      const detallesF = detallesFacturas.filter(d => d.factura?.nro_pedido === pedido.nro_pedido);
+      const cantidadFacturada = detallesF.reduce((acc, d) => acc + parseFloat(d.cantidad || 0), 0);
+
+      const fillRate = cantidadPedida > 0 ? Math.min((cantidadFacturada / cantidadPedida) * 100, 100) : null;
+
+     const leadTime = facturasDelPedido.length
+  ? Math.max(0, Math.round((new Date(facturasDelPedido[0].fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24)))
+  : null;
+
+      return {
+        pedidoId: pedido.id,
+        nroPedido: pedido.nro_pedido,
+        fecha: pedido.fecha,
+        leadTimeDias: leadTime,
+        fillRate: fillRate !== null ? +fillRate.toFixed(2) : null,
+        cantidadPedida,
+        cantidadFacturada
+      };
+    });
+
+    res.json(resultado);
+  } catch (error) {
+    console.error('Error en obtenerEficienciaPorPedido:', error);
+    res.status(500).json({ error: 'Error al calcular eficiencia por pedido' });
+  }
+};
+
+export const obtenerDetallePorPedido = async (req, res) => {
+  try {
+    const { pedidoId } = req.query;
+    if (!pedidoId) return res.status(400).json({ error: "Falta el parámetro 'pedidoId'" });
+
+    const pedido = await PedidoDux.findByPk(pedidoId);
+    if (!pedido) return res.status(404).json({ error: "Pedido no encontrado" });
+
+    const detallesPedido = await DetallePedidoDux.findAll({
+      where: { pedidoDuxId: pedidoId },
+      attributes: ['codItem', 'descripcion', 'cantidad']
+    });
+
+    const facturas = await Factura.findAll({
+      where: {
+        nro_pedido: pedido.nro_pedido,
+        anulada_boolean: false,
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        }
+      },
+      attributes: ['fecha_comp'],
+      include: [{
+        model: DetalleFactura,
+        as: "detalles",
+        attributes: ['codItem', 'cantidad']
+      }],
+    });
+
+    const mapFacturadas = {};
+    for (const factura of facturas) {
+      for (const det of factura.detalles || []) {
+        const cod = det.codItem;
+        const cant = parseFloat(det.cantidad || 0);
+        if (!mapFacturadas[cod]) mapFacturadas[cod] = 0;
+        mapFacturadas[cod] += cant;
+      }
+    }
+
+    let leadTimePedido = null;
+    let fechasFacturas = [];
+
+    if (facturas.length) {
+      const fechas = facturas.map(f => new Date(f.fecha_comp)).sort((a, b) => a - b);
+      const fechaFacturaMasTemprana = fechas[0];
+
+      leadTimePedido = Math.max(
+        0,
+        Math.round((fechaFacturaMasTemprana - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24))
+      );
+
+      fechasFacturas = fechas.map(f => f.toISOString().split("T")[0]);
+    }
+    const resultado = detallesPedido.map(p => {
+      const cantidadPedida = parseFloat(p.cantidad || 0);
+      const cantidadFacturada = mapFacturadas[p.codItem] || 0;
+      const fillRate = cantidadPedida > 0
+        ? Math.min((cantidadFacturada / cantidadPedida) * 100, 100)
+        : 0;
+
+      return {
+        codItem: p.codItem,
+        descripcion: p.descripcion || "Sin descripción",
+        pedida: cantidadPedida,
+        facturada: cantidadFacturada,
+        fillRate: +fillRate.toFixed(2),
+        fechasFacturas,
+        leadTimeDias: leadTimePedido
+      };
+    });
+    
+    res.json({
+      leadTimePedido,
+      fechasFacturas,
+      productos: resultado
+    });
+  } catch (error) {
+    console.error("Error en obtenerDetallePorPedido:", error);
+    res.status(500).json({ error: "Error al obtener detalle del pedido" });
+  }
+};
+
+export const obtenerEficienciaPorProducto = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+    const filtro = req.query.producto?.toLowerCase() || "";
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        where: {
+          fecha: { [Op.between]: [desde, hasta] },
+        },
+        attributes: []
+      }
+    });
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false
+        },
+        attributes: ['id', 'fecha_comp', 'nro_pedido'] // necesario para lead time
+      }
+    });
+
+    const pedidasPorProducto = {};
+    const facturadasPorProducto = {};
+
+    for (const d of detallesPedidos) {
+      const key = d.codItem;
+      const descripcion = d.descripcion || "";
+      if (!filtro || key.toLowerCase().includes(filtro) || descripcion.toLowerCase().includes(filtro)) {
+        pedidasPorProducto[key] = pedidasPorProducto[key] || { producto: descripcion, pedida: 0 };
+        pedidasPorProducto[key].pedida += parseFloat(d.cantidad || 0);
+      }
+    }
+
+    for (const d of detallesFacturas) {
+      const key = d.codItem;
+      const descripcion = d.descripcion || "";
+      if (!filtro || key.toLowerCase().includes(filtro) || descripcion.toLowerCase().includes(filtro)) {
+        facturadasPorProducto[key] = facturadasPorProducto[key] || { producto: descripcion, facturada: 0, leadTimes: [] };
+        facturadasPorProducto[key].facturada += parseFloat(d.cantidad || 0);
+
+        // ✅ calcular lead time solo si hay nro_pedido
+        const nroPedido = d.factura?.nro_pedido;
+        if (nroPedido) {
+          const pedido = await PedidoDux.findOne({
+            where: { nro_pedido: nroPedido },
+            attributes: ['fecha']
+          });
+
+          if (pedido?.fecha) {
+            const diff = Math.round(
+              (new Date(d.factura.fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24)
+            );
+            if (diff >= 0) facturadasPorProducto[key].leadTimes.push(diff);
+          }
+        } else {
+          console.warn(`⚠️ Factura sin nro_pedido (id: ${d.factura?.id})`);
+        }
+      }
+    }
+
+    const resultado = Object.keys(pedidasPorProducto).map(key => {
+      const pedida = pedidasPorProducto[key].pedida || 0;
+      const facturada = facturadasPorProducto[key]?.facturada || 0;
+      const leadTimes = facturadasPorProducto[key]?.leadTimes || [];
+
+      const fillRate = pedida > 0 ? Math.min((facturada / pedida) * 100, 100) : null;
+      const leadTimePromedio = leadTimes.length > 0
+        ? +(leadTimes.reduce((a, b) => a + b, 0) / leadTimes.length).toFixed(2)
+        : null;
+
+      return {
+        producto: pedidasPorProducto[key].producto || key,
+        cantidadPedida: pedida,
+        cantidadFacturada: facturada,
+        fillRate: fillRate !== null ? +fillRate.toFixed(2) : null,
+        leadTimePromedio
+      };
+    });
+
+    res.json(resultado);
+  } catch (err) {
+    console.error("Error en obtenerEficienciaPorProducto:", err);
+    res.status(500).json({ error: "Error al calcular eficiencia por producto" });
+  }
+};
+
+export const obtenerDetallePorProducto = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        where: { fecha: { [Op.between]: [desde, hasta] } },
+        attributes: []
+      }
+    });
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false
+        },
+        attributes: []
+      }
+    });
+
+    const map = new Map();
+
+    for (const d of detallesPedidos) {
+      const key = d.codItem;
+      const desc = d.descripcion || key;
+      if (!map.has(key)) {
+        map.set(key, { codItem: key, descripcion: desc, pedida: 0, facturada: 0 });
+      }
+      const item = map.get(key);
+      item.pedida += parseFloat(d.cantidad || 0);
+    }
+
+    for (const d of detallesFacturas) {
+      const key = d.codItem;
+      const desc = d.descripcion || key;
+      if (!map.has(key)) {
+        map.set(key, { codItem: key, descripcion: desc, pedida: 0, facturada: 0 });
+      }
+      const item = map.get(key);
+      item.facturada += parseFloat(d.cantidad || 0);
+    }
+
+    const resultado = Array.from(map.values()).map((item) => ({
+      ...item,
+      diferencia: +(item.facturada - item.pedida).toFixed(2)
+    }));
+
+    res.json(resultado);
+  } catch (err) {
+    console.error("Error en obtenerDetallePorProducto:", err);
+    res.status(500).json({ error: "Error al generar detalle por producto" });
+  }
+};
+
+export const obtenerEficienciaPorCategoria = async (req, res) => {
+  try {
+    const desde = req.query.desde ? new Date(req.query.desde) : null;
+    const hasta = req.query.hasta ? new Date(req.query.hasta) : null;
+    const categoriaId = req.query.categoriaId || null;
+
+    if (!desde || !hasta) {
+      return res.status(400).json({ error: "Parámetros 'desde' y 'hasta' son requeridos" });
+    }
+
+    // ✅ Categorías válidas (excluye las que contienen "producción")
+    const categorias = await Categoria.findAll({
+      where: where(fn('LOWER', col('nombre')), {
+        [Op.notLike]: '%producción%'
+      }),
+      attributes: ['id', 'nombre']
+    });
+    const categoriasValidas = new Set(categorias.map(c => c.id));
+    const categoriaNombreMap = new Map(categorias.map(c => [c.id, c.nombre]));
+
+    // ✅ Productos que pertenecen solo a categorías válidas
+    const productos = await Producto.findAll({
+      where: { categoriaId: { [Op.in]: Array.from(categoriasValidas) } },
+      attributes: ['sku', 'categoriaId']
+    });
+    const productoCategoriaMap = new Map(productos.map(p => [p.sku, p.categoriaId]));
+
+    // ✅ Pedidos válidos
+    const pedidos = await PedidoDux.findAll({
+      attributes: ['nro_pedido', 'fecha']
+    });
+    const pedidoFechaMap = new Map(pedidos.map(p => [p.nro_pedido, p.fecha]));
+
+    const resumenPorCategoria = {};
+    const codItemsPedidos = new Set();
+
+    // 🧾 Detalles de pedidos (filtrados por fecha)
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        where: { fecha: { [Op.between]: [desde, hasta] } },
+        attributes: ['id', 'fecha'],
+      }
+    });
+
+    for (const d of detallesPedidos) {
+      const codItem = d.codItem;
+      const catId = productoCategoriaMap.get(codItem);
+      if (!catId || (categoriaId && catId != categoriaId)) continue;
+
+      codItemsPedidos.add(codItem); // ✅ registrar que este item fue pedido
+
+      if (!resumenPorCategoria[catId]) {
+        resumenPorCategoria[catId] = {
+          nombre: categoriaNombreMap.get(catId) || 'Sin categoría',
+          cantidadPedida: 0,
+          cantidadFacturada: 0,
+          leadTimes: [],
+        };
+      }
+
+      resumenPorCategoria[catId].cantidadPedida += parseFloat(d.cantidad || 0);
+    }
+
+    // 🧾 Detalles de facturas (no anuladas y con pedido válido)
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false,
+        },
+        attributes: ['fecha_comp', 'nro_pedido'],
+      }
+    });
+
+    for (const d of detallesFacturas) {
+      const codItem = d.codItem;
+      const catId = productoCategoriaMap.get(codItem);
+      if (!catId || (categoriaId && catId != categoriaId)) continue;
+
+      if (!codItemsPedidos.has(codItem)) continue; // ❌ ignorar si no fue pedido
+
+      const cantidadFacturada = parseFloat(d.cantidad || 0);
+      if (cantidadFacturada === 0) continue;
+
+      const fechaPedido = pedidoFechaMap.get(d.factura?.nro_pedido);
+      if (!fechaPedido) continue; // ❌ ignorar si no tiene pedido asociado
+
+      if (!resumenPorCategoria[catId]) {
+        resumenPorCategoria[catId] = {
+          nombre: categoriaNombreMap.get(catId) || 'Sin categoría',
+          cantidadPedida: 0,
+          cantidadFacturada: 0,
+          leadTimes: [],
+        };
+      }
+
+      resumenPorCategoria[catId].cantidadFacturada += cantidadFacturada;
+
+      const dias = Math.round((new Date(d.factura.fecha_comp) - new Date(fechaPedido)) / (1000 * 60 * 60 * 24));
+      if (dias >= 0) resumenPorCategoria[catId].leadTimes.push(dias);
+    }
+
+    // 📊 Resultado final
+    const resultado = Object.entries(resumenPorCategoria)
+      .filter(([_, data]) => data.cantidadFacturada > 0)
+      .map(([catId, data]) => {
+        const fillRate = data.cantidadPedida > 0
+          ? Math.min((data.cantidadFacturada / data.cantidadPedida) * 100, 100)
+          : null;
+
+        const leadTimePromedio = data.leadTimes.length > 0
+          ? +(data.leadTimes.reduce((a, b) => a + b, 0) / data.leadTimes.length).toFixed(2)
+          : null;
+
+        return {
+          categoria: catId,
+          categoriaNombre: data.nombre,
+          cantidadPedida: data.cantidadPedida,
+          cantidadFacturada: data.cantidadFacturada,
+          fillRate: fillRate !== null ? +fillRate.toFixed(2) : null,
+          leadTimePromedio
+        };
+      });
+
+    res.json(resultado);
+  } catch (err) {
+    console.error("Error en obtenerEficienciaPorCategoria:", err);
+    res.status(500).json({ error: "Error al calcular eficiencia por categoría" });
+  }
+};
+
+export const obtenerDetallePorCategoria = async (req, res) => {
+  try {
+    const { desde, hasta, categoriaId } = req.query;
+
+    if (!desde || !hasta || !categoriaId) {
+      return res.status(400).json({ error: "Parámetros 'desde', 'hasta' y 'categoriaId' son requeridos" });
+    }
+
+    const desdeFecha = new Date(desde);
+    const hastaFecha = new Date(hasta);
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        where: { fecha: { [Op.between]: [desdeFecha, hastaFecha] } },
+        attributes: ['id', 'nro_pedido', 'fecha']
+      }
+    });
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desdeFecha, hastaFecha] },
+          anulada_boolean: false
+        },
+        attributes: ['nro_pedido', 'fecha_comp']
+      }
+    });
+
+    const productoCache = new Map();
+
+    const perteneceACategoria = async (codItem) => {
+      if (productoCache.has(codItem)) return productoCache.get(codItem);
+
+      const prod = await Producto.findOne({ where: { sku: codItem } });
+      const pertenece = prod?.categoriaId?.toString() === categoriaId;
+      productoCache.set(codItem, pertenece);
+      return pertenece;
+    };
+
+    const agrupado = {};
+
+    for (const d of detallesPedidos) {
+      if (await perteneceACategoria(d.codItem)) {
+        const pedido = d.pedidoDux;
+        if (!agrupado[pedido.nro_pedido]) {
+          agrupado[pedido.nro_pedido] = {
+            nroPedido: pedido.nro_pedido,
+            fecha: pedido.fecha,
+            cantidadPedida: 0,
+            cantidadFacturada: 0,
+            leadTimeDias: null
+          };
+        }
+        agrupado[pedido.nro_pedido].cantidadPedida += parseFloat(d.cantidad || 0);
+      }
+    }
+
+    for (const d of detallesFacturas) {
+      if (await perteneceACategoria(d.codItem)) {
+        const nro = d.factura?.nro_pedido;
+        if (nro && agrupado[nro]) {
+          agrupado[nro].cantidadFacturada += parseFloat(d.cantidad || 0);
+          if (d.factura.fecha_comp && agrupado[nro].fecha) {
+            const diff = Math.round(
+              (new Date(d.factura.fecha_comp) - new Date(agrupado[nro].fecha)) / (1000 * 60 * 60 * 24)
+            );
+            if (diff >= 0) agrupado[nro].leadTimeDias = diff;
+          }
+        }
+      }
+    }
+
+    const resultado = Object.values(agrupado).map((p) => {
+      const fillRate = p.cantidadPedida > 0
+        ? Math.min((p.cantidadFacturada / p.cantidadPedida) * 100, 100)
+        : 0;
+
+      return {
+        ...p,
+        fillRate: +fillRate.toFixed(2)
+      };
+    });
+
+    res.json(resultado);
+  } catch (err) {
+    console.error("Error en obtenerDetallePorCategoria:", err);
+    res.status(500).json({ error: "Error al generar detalle por categoría" });
+  }
+};
+
+export const obtenerEficienciaPorCliente = async (req, res) => {
+  try {
+    const { desde, hasta, cliente } = req.query;
+    if (!desde || !hasta) return res.status(400).json({ error: "Faltan fechas" });
+
+    const fechaDesde = new Date(desde);
+    const fechaHasta = new Date(hasta);
+    const filtroCliente = cliente?.toLowerCase() || "";
+
+    const pedidos = await PedidoDux.findAll({
+      where: {
+        fecha: { [Op.between]: [fechaDesde, fechaHasta] },
+        ...(filtroCliente && { cliente: { [Op.like]: `%${filtroCliente}%` } }),
+      },
+      attributes: ["id", "nro_pedido", "fecha", "cliente"],
+    });
+
+    const nroPedidos = pedidos.map(p => p.nro_pedido);
+
+    const facturas = await Factura.findAll({
+      where: {
+        fecha_comp: { [Op.between]: [fechaDesde, fechaHasta] },
+        anulada_boolean: false,
+        nro_pedido: { [Op.in]: nroPedidos },
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        }
+      },
+    });
+
+    const detallesPedidos = await DetallePedidoDux.findAll();
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        attributes: ["nro_pedido"],
+      },
+    });
+
+    const clientesMap = new Map();
+
+    for (const pedido of pedidos) {
+      const cliente = pedido.cliente || "Sin nombre";
+      const factura = facturas.find(f => f.nro_pedido === pedido.nro_pedido);
+      const detallesP = detallesPedidos.filter(d => d.pedidoDuxId === pedido.id);
+      const detallesF = detallesFacturas.filter(d => d.factura?.nro_pedido === pedido.nro_pedido);
+
+      const cantidadPedida = detallesP.reduce((acc, d) => acc + parseFloat(d.cantidad || 0), 0);
+      const cantidadFacturada = detallesF.reduce((acc, d) => acc + parseFloat(d.cantidad || 0), 0);
+
+      const totalPedido = detallesP.reduce((acc, d) => acc + (parseFloat(d.cantidad || 0) * parseFloat(d.precioUnitario || 0)), 0);
+      const totalFacturado = detallesF.reduce((acc, d) => acc + (parseFloat(d.cantidad || 0) * parseFloat(d.precioUnitario || 0)), 0);
+
+      if (cantidadFacturada === 0) continue;
+
+      const fillRate = cantidadPedida > 0
+        ? Math.min((cantidadFacturada / cantidadPedida) * 100, 100)
+        : null;
+
+      const fillRatePonderado = totalPedido > 0
+        ? Math.min((totalFacturado / totalPedido) * 100, 100)
+        : null;
+
+      const leadTime = factura
+        ? Math.max(0, Math.round((new Date(factura.fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24)))
+        : null;
+
+      if (!clientesMap.has(cliente)) {
+        clientesMap.set(cliente, {
+          cliente,
+          pedidos: [],
+          leadTimes: [],
+          totalPedida: 0,
+          totalFacturada: 0,
+          totalPedido: 0,
+          totalFacturado: 0,
+          ponderados: [],
+        });
+      }
+
+      const entry = clientesMap.get(cliente);
+      if (fillRate !== null) entry.pedidos.push(fillRate);
+      if (fillRatePonderado !== null) entry.ponderados.push(fillRatePonderado);
+      if (leadTime !== null) entry.leadTimes.push(leadTime);
+      entry.totalPedida += cantidadPedida;
+      entry.totalFacturada += cantidadFacturada;
+      entry.totalPedido += totalPedido;
+      entry.totalFacturado += totalFacturado;
+    }
+
+    const resultado = Array.from(clientesMap.values()).map(entry => {
+      return {
+        cliente: entry.cliente,
+        cantidadPedida: entry.totalPedida,
+        cantidadFacturada: entry.totalFacturada,
+        fillRate: entry.pedidos.length
+          ? +(entry.pedidos.reduce((a, b) => a + b, 0) / entry.pedidos.length).toFixed(2)
+          : null,
+        fillRatePonderado: entry.ponderados.length
+          ? +(entry.ponderados.reduce((a, b) => a + b, 0) / entry.ponderados.length).toFixed(2)
+          : null,
+        leadTimePromedio: entry.leadTimes.length
+          ? +(entry.leadTimes.reduce((a, b) => a + b, 0) / entry.leadTimes.length).toFixed(2)
+          : null,
+        totalPedido: +entry.totalPedido.toFixed(2),
+        totalFacturado: +entry.totalFacturado.toFixed(2),
+      };
+    });
+
+    res.json(resultado);
+  } catch (error) {
+    console.error("Error en obtenerEficienciaPorCliente:", error);
+    res.status(500).json({ error: "Error al calcular eficiencia por cliente" });
+  }
+};
+
+export const obtenerDetallePorCliente = async (req, res) => {
+  try {
+    const { desde, hasta, cliente } = req.query;
+
+    if (!desde || !hasta || !cliente) {
+      return res.status(400).json({ error: "Faltan parámetros requeridos" });
+    }
+
+    const pedidos = await PedidoDux.findAll({
+      where: {
+        cliente,
+        fecha: { [Op.between]: [new Date(desde), new Date(hasta)] },
+      },
+      attributes: ['id', 'nro_pedido', 'fecha']
+    });
+
+    const nroPedidos = pedidos.map(p => p.nro_pedido);
+    const pedidosMap = new Map(pedidos.map(p => [p.nro_pedido, p]));
+
+    const facturas = await Factura.findAll({
+      where: {
+        nro_pedido: { [Op.in]: nroPedidos },
+        anulada_boolean: false,
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        }
+      },
+      attributes: ['nro_pedido', 'fecha_comp']
+    });
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      where: { pedidoDuxId: { [Op.in]: pedidos.map(p => p.id) } }
+    });
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: { nro_pedido: { [Op.in]: nroPedidos } }
+      }
+    });
+
+    const facturasMap = new Map(facturas.map(f => [f.nro_pedido, f]));
+
+    const resultado = pedidos.map(pedido => {
+      const detallesP = detallesPedidos.filter(d => d.pedidoDuxId === pedido.id);
+      const cantidadPedida = detallesP.reduce((acc, d) => acc + parseFloat(d.cantidad || 0), 0);
+      const totalPedido = detallesP.reduce((acc, d) => acc + (parseFloat(d.cantidad || 0) * parseFloat(d.precioUnitario || 0)), 0);
+
+      const detallesF = detallesFacturas.filter(d => d.factura?.nro_pedido === pedido.nro_pedido);
+      const cantidadFacturada = detallesF.reduce((acc, d) => acc + parseFloat(d.cantidad || 0), 0);
+      const totalFacturado = detallesF.reduce((acc, d) => acc + (parseFloat(d.cantidad || 0) * parseFloat(d.precioUnitario || 0)), 0);
+
+      const fillRate = cantidadPedida > 0
+        ? Math.min((cantidadFacturada / cantidadPedida) * 100, 100)
+        : null;
+
+      const fillRatePonderado = totalPedido > 0
+        ? Math.min((totalFacturado / totalPedido) * 100, 100)
+        : null;  
+
+      const factura = facturasMap.get(pedido.nro_pedido);
+      const leadTimeDias =
+        factura && cantidadFacturada > 0
+          ? Math.max(0, Math.round((new Date(factura.fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24)))
+          : null;
+
+      const fechasFacturas = facturas
+        .filter(f => f.nro_pedido === pedido.nro_pedido)
+        .map(f => f.fecha_comp);
+      return {
+        pedidoId: pedido.id,
+        nroPedido: pedido.nro_pedido,
+        fecha: pedido.fecha,
+        fechasFacturas,
+        cantidadPedida,
+        cantidadFacturada,
+        fillRate: fillRate !== null ? +fillRate.toFixed(2) : null,
+        leadTimeDias,
+        totalPedido: +totalPedido.toFixed(2),
+        totalFacturado: +totalFacturado.toFixed(2),
+        fillRatePonderado: fillRatePonderado !== null ? +fillRatePonderado.toFixed(2) : null,
+      };
+    });
+
+    res.json(resultado);
+  } catch (error) {
+    console.error("Error en obtenerDetalleCliente:", error);
+    res.status(500).json({ error: "Error al obtener detalle del cliente" });
+  }
+};
+
+export const obtenerEvolucionEficienciaMensualPorCliente = async (req, res) => {
+  try {
+    const desde = "2015-01-01";
+    const hasta = new Date();
+    const cliente = req.query.cliente?.toLowerCase();
+
+    if (!hasta || !cliente) {
+      return res.status(400).json({ error: "Parámetros 'hasta' y 'cliente' son requeridos" });
+    }
+
+    const wherePedidos = {
+      fecha: { [Op.between]: [desde, hasta] },
+      cliente: { [Op.like]: `%${cliente}%` }
+    };
+
+    const pedidos = await PedidoDux.findAll({
+      where: wherePedidos,
+      attributes: ["id", "fecha", "nro_pedido"],
+    });
+
+    const idPedidos = pedidos.map(p => p.id);
+    const nroPedidos = pedidos.map(p => p.nro_pedido);
+    const pedidosPorNro = new Map(pedidos.map(p => [p.nro_pedido, p]));
+
+    const detallesPedidos = await DetallePedidoDux.findAll({
+      where: { pedidoDuxId: { [Op.in]: idPedidos } },
+      include: {
+        model: PedidoDux,
+        as: "pedidoDux",
+        attributes: ["fecha"]
+      }
+    });
+
+    const facturas = await Factura.findAll({
+      where: {
+        fecha_comp: { [Op.between]: [desde, hasta] },
+        anulada_boolean: false,
+        tipo_comp: {
+          [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+        },
+        nro_pedido: { [Op.in]: nroPedidos },
+      },
+      attributes: ["nro_pedido", "fecha_comp"],
+    });
+
+    const facturasPorNro = new Map(facturas.map(f => [f.nro_pedido, f]));
+
+    const detallesFacturas = await DetalleFactura.findAll({
+      include: {
+        model: Factura,
+        as: "factura",
+        where: {
+          fecha_comp: { [Op.between]: [desde, hasta] },
+          anulada_boolean: false,
+          tipo_comp: {
+            [Op.in]: ["FACTURA", "COMPROBANTE_VENTA", "NOTA_DEBITO", "FACTURA_FCE_MIPYMES"]
+          },
+          nro_pedido: { [Op.in]: nroPedidos }
+        },
+        attributes: ["fecha_comp", "nro_pedido"]
+      }
+    });
+
+    const dataPorMes = {};
+
+    for (const d of detallesPedidos) {
+      const mes = dayjs(d.pedidoDux.fecha).format("YYYY-MM");
+      dataPorMes[mes] = dataPorMes[mes] || { pedida: 0, facturada: 0, totalLeadTime: 0, countLeadTime: 0 };
+      dataPorMes[mes].pedida += parseFloat(d.cantidad || "0");
+    }
+
+    for (const d of detallesFacturas) {
+      const nro = d.factura.nro_pedido;
+      const factura = d.factura;
+      const pedido = pedidosPorNro.get(nro);
+      if (!pedido) continue;
+
+      const mes = dayjs(factura.fecha_comp).format("YYYY-MM");
+
+      dataPorMes[mes] = dataPorMes[mes] || { pedida: 0, facturada: 0, totalLeadTime: 0, countLeadTime: 0 };
+      dataPorMes[mes].facturada += parseFloat(d.cantidad || "0");
+
+      const dias = Math.max(0, Math.round((new Date(factura.fecha_comp) - new Date(pedido.fecha)) / (1000 * 60 * 60 * 24)));
+      dataPorMes[mes].totalLeadTime += dias;
+      dataPorMes[mes].countLeadTime += 1;
+    }
+
+    const resultado = Object.entries(dataPorMes)
+      .sort(([a], [b]) => a.localeCompare(b))
+      .map(([mes, v]) => ({
+        mes,
+        fillRate: v.pedida > 0 ? +(Math.min(v.facturada / v.pedida, 1) * 100).toFixed(2) : 0,
+        leadTime: v.countLeadTime > 0 ? +(v.totalLeadTime / v.countLeadTime).toFixed(2) : null
+      }));
+
+    res.json(resultado);
+  } catch (error) {
+    console.error("Error en obtenerEvolucionEficienciaMensualPorCliente:", error);
+    res.status(500).json({ error: "Error al calcular eficiencia mensual por cliente" });
+  }
+};
+
+
+
diff --git a/backend-nest/src/estadisticas/estadisticas.controller.ts b/backend-nest/src/estadisticas/estadisticas.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..85498afefba22e1294c33bf09d8ae6f1f1ddc1bf
--- /dev/null
+++ b/backend-nest/src/estadisticas/estadisticas.controller.ts
@@ -0,0 +1,318 @@
+import { Pedido, DetallePedido, Producto, Cliente, Usuario, Categoria, ImagenProducto, LogCliente } from '@/models';
+import { ROLES_USUARIOS } from '@/constants/rolesUsuarios';
+import { Op, fn, col, literal } from 'sequelize';
+import dayjs from 'dayjs';
+import cache from '@/utils/cache';
+
+export const obtenerResumenEstadisticas = async (req, res, next) => {
+  try {
+    const inicioMes = dayjs().startOf('month').toDate();
+    const finMes = dayjs().endOf('month').toDate();
+
+    const cacheKey = `resumenEstadisticas_${req.usuario.id}_${dayjs().format('YYYY_MM')}`;
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    const wherePedidos = { createdAt: { [Op.between]: [inicioMes, finMes] } };
+    if (req.usuario?.rolUsuarioId === ROLES_USUARIOS.VENDEDOR) {
+      wherePedidos.usuarioId = req.usuario.id;
+    }
+    // Consultas principales
+    const totalPedidos = await Pedido.count({ where: wherePedidos });
+    const totalFacturado = await Pedido.sum('total', { where: wherePedidos });
+
+    const productoTop = await DetallePedido.findOne({
+      attributes: ['productoId', [fn('SUM', col('cantidad')), 'totalVendidas'], [fn('SUM', col('subtotal')), 'totalFacturado']],
+      include: [{ model: Pedido, as: 'pedido', where: wherePedidos, attributes: [] }],
+      group: ['productoId'],
+      order: [[literal('totalVendidas'), 'DESC']],
+      raw: true,
+    });
+
+    let productoEstrella = null;
+    if (productoTop) {
+      const producto = await Producto.findByPk(productoTop.productoId, {
+        include: [{ model: ImagenProducto, as: 'Imagenes', attributes: ['url'], required: false }],
+        attributes: ['id', 'nombre'],
+        paranoid: false,
+      });
+
+      productoEstrella = {
+        productoId: productoTop.productoId,
+        totalVendidas: Number(productoTop.totalVendidas),
+        totalFacturado: Number(productoTop.totalFacturado),
+        Producto: {
+          nombre: producto?.nombre || null,
+          imagenUrl: Array.isArray(producto?.Imagenes) ? producto.Imagenes[0]?.url || null : null,
+        },
+      };
+    }
+
+    const vendedorTop = await Pedido.findOne({
+      attributes: ['usuarioId', [fn('COUNT', col('Pedido.id')), 'cantidad'], [fn('SUM', col('Pedido.total')), 'totalFacturado']],
+      include: [{ model: Usuario, as: 'usuario', attributes: ['nombre'] }],
+      where: wherePedidos,
+      group: ['usuarioId'],
+      order: [[literal('cantidad'), 'DESC']],
+      limit: 1,
+    });
+
+    const mejoresClientes = await Pedido.findAll({
+      attributes: ['clienteId', [fn('SUM', col('total')), 'totalGastado']],
+      include: [{ model: Cliente, as: 'cliente', attributes: ['nombre'] }],
+      where: wherePedidos,
+      group: ['clienteId'],
+      order: [[literal('totalGastado'), 'DESC']],
+      limit: 5,
+    });
+
+    const categoriaTop = await DetallePedido.findOne({
+      attributes: [[col('producto.categoriaId'), 'categoriaId'], [fn('SUM', col('subtotal')), 'totalFacturado']],
+      include: [
+        { 
+          model: Producto,
+          as: 'producto',
+          attributes: [],
+          include: [{ model: Categoria, as: 'Categoria', attributes: ['nombre'], required: true }],
+          required: true
+        },
+        { model: Pedido, as: 'pedido', where: wherePedidos, attributes: [] }
+      ],
+      group: ['producto.categoriaId'],
+      order: [[literal('totalFacturado'), 'DESC']],
+      raw: true,
+      nest: true,
+    });
+
+    const result = {
+      totalPedidos,
+      totalFacturado,
+      productoEstrella,
+      vendedorTop,
+      categoriaTop: categoriaTop?.producto?.Categoria ?? null,
+      mejoresClientes,
+    };
+
+    cache.set(cacheKey, result, 60 * 10); // cachea por 10 minutos
+    reson(result);
+
+  } catch (error) {
+    console.error('❌ Error en resumen de estadísticas:', error);
+    next(error);
+  }
+};
+
+export const obtenerEstadisticasPorFecha = async (req, res, next) => {
+  try {
+    const { desde, hasta } = req.query;
+
+    if (!desde || !hasta) {
+      return res.status(400)on({ message: 'Faltan fechas desde/hasta' });
+    }
+
+    const desdeFecha = dayjs(desde).startOf('day').toDate();
+    const hastaFecha = dayjs(hasta).endOf('day').toDate();
+
+    const pedidos = await Pedido.findAll({
+      attributes: [
+        [fn('DATE', col('createdAt')), 'fecha'],
+        [fn('SUM', col('total')), 'total'],
+        [fn('COUNT', col('id')), 'cantidad'],
+      ],
+      where: {
+        createdAt: { [Op.between]: [desdeFecha, hastaFecha] },
+      },
+      group: [literal('DATE(createdAt)')],
+      order: [[literal('fecha'), 'ASC']],
+      raw: true,
+    });
+
+    reson(pedidos);
+  } catch (error) {
+    console.error('❌ Error en estadísticas por fecha:', error);
+    next(error);
+  }
+};
+
+export const compararRangos = async (req, res, next) => {
+  try {
+    const { desde1, hasta1, desde2, hasta2 } = req.query;
+
+    if (!desde1 || !hasta1 || !desde2 || !hasta2) {
+      return res.status(400)on({ message: 'Faltan fechas en alguno de los rangos' });
+    }
+
+    const rangos = [
+      { desde: dayjs(desde1).startOf('day').toDate(), hasta: dayjs(hasta1).endOf('day').toDate() },
+      { desde: dayjs(desde2).startOf('day').toDate(), hasta: dayjs(hasta2).endOf('day').toDate() }
+    ];
+
+    const resultados = [];
+
+    for (const { desde, hasta } of rangos) {
+      const totalPedidos = await Pedido.count({ where: { createdAt: { [Op.between]: [desde, hasta] } } });
+      const totalFacturado = await Pedido.sum('total', { where: { createdAt: { [Op.between]: [desde, hasta] } } });
+
+      const productoTop = await DetallePedido.findOne({
+        attributes: [
+          'productoId',
+          [fn('SUM', col('cantidad')), 'cantidad'],
+        ],
+        include: [{ model: Producto, as: 'producto', attributes: ['nombre'], required: true }],
+        where: { createdAt: { [Op.between]: [desde, hasta] } },
+        group: ['productoId'],
+        order: [[literal('cantidad'), 'DESC']],
+        limit: 1,
+      });
+
+      resultados.push({ totalPedidos, totalFacturado, productoTop });
+    }
+
+    reson({ rango1: resultados[0], rango2: resultados[1] });
+  } catch (error) {
+    console.error('❌ Error al comparar rangos:', error);
+    next(error);
+  }
+};
+
+export const obtenerRankingEstadisticas = async (req, res, next) => {
+  try {
+    const { desde, hasta } = req.query;
+
+    const inicio = desde ? dayjs(desde).startOf('day').toDate() : dayjs().startOf('month').toDate();
+    const fin = hasta ? dayjs(hasta).endOf('day').toDate() : dayjs().endOf('month').toDate();
+
+    const whereFecha = { createdAt: { [Op.between]: [inicio, fin] } };
+
+    const productos = await DetallePedido.findAll({
+      attributes: [
+        'productoId',
+        [fn('SUM', col('cantidad')), 'cantidadVendida'],
+        [fn('SUM', col('subtotal')), 'totalFacturado'],
+      ],
+      include: [{ model: Producto, as: 'producto', attributes: ['nombre'], required: true }],
+      where: whereFecha,
+      group: ['productoId'],
+      order: [[literal('cantidadVendida'), 'DESC']],
+      limit: 10,
+    });
+
+    const vendedores = await Pedido.findAll({
+      attributes: [
+        'usuarioId',
+        [fn('COUNT', col('Pedido.id')), 'totalPedidos'],
+        [fn('SUM', col('total')), 'totalFacturado'],
+      ],
+      include: [{ model: Usuario, as: 'usuario', attributes: ['nombre'] }],
+      where: whereFecha,
+      group: ['usuarioId'],
+      order: [[literal('totalFacturado'), 'DESC']],
+      limit: 10,
+    });
+
+    const clientes = await Pedido.findAll({
+      attributes: [
+        'clienteId',
+        [fn('COUNT', col('Pedido.id')), 'cantidadPedidos'],
+        [fn('SUM', col('total')), 'totalGastado'],
+      ],
+      include: [{ model: Cliente, as: 'cliente', attributes: ['nombre'] }],
+      where: whereFecha,
+      group: ['clienteId'],
+      order: [[literal('totalGastado'), 'DESC']],
+      limit: 10,
+    });
+
+    const categorias = await DetallePedido.findAll({
+      attributes: [
+        [col('producto.categoriaId'), 'categoriaId'],
+        [fn('SUM', col('subtotal')), 'totalFacturado'],
+        [col('producto.Categoria.nombre'), 'nombre'],
+      ],
+      include: [{
+        model: Producto,
+        as: 'producto', // alias correcto
+        attributes: [],
+        include: [{
+          model: Categoria,
+          as: 'Categoria', // alias correcto
+          attributes: [],
+        }],
+        required: true,
+      }],
+      where: whereFecha,
+      group: ['producto.categoriaId'],
+      order: [[literal('totalFacturado'), 'DESC']],
+      limit: 10,
+      raw: true,
+    });
+    
+
+    reson({ productos, vendedores, clientes, categorias });
+  } catch (error) {
+    console.error('❌ Error en estadísticas ranking:', error);
+    next(error);
+  }
+};
+
+export const obtenerEstadisticasProducto = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+
+    const [ventas, unidadesVendidas, facturacion, visitas] = await Promise.all([
+      Pedido.count({
+        include: [{ model: DetallePedido, as: 'detalles', where: { productoId: id }, required: true }],
+      }),      
+      DetallePedido.sum('cantidad', { where: { productoId: id } }),
+      DetallePedido.sum('subtotal', { where: { productoId: id } }),
+      LogCliente.count({ where: { busqueda: `detalle:${id}` } }),
+    ]);
+
+    reson({
+      ventas: ventas || 0,
+      unidadesVendidas: unidadesVendidas || 0,
+      facturacion: facturacion || 0,
+      visitas: visitas || 0,
+    });
+  } catch (error) {
+    console.error('❌ Error en obtenerEstadisticasProducto:', error);
+    next(error);
+  }
+};
+
+export const obtenerVentasPorCategoria = async (req, res) => {
+  try {
+    const resultados = await DetallePedido.findAll({
+      attributes: [
+        [fn('SUM', col('subtotal')), 'totalVentas'],
+        [col('producto.Categoria.nombre'), 'categoria'],
+      ],
+      include: [
+        {
+          model: Producto,
+          as: 'producto',
+          attributes: [],
+          include: [{
+            model: Categoria,
+            as: 'Categoria', // correcto según tu modelo
+            attributes: [],
+          }],
+          required: true,
+        }
+      ],
+      where: { deletedAt: null },
+      group: ['producto.Categoria.nombre'],
+      raw: true,
+    });
+
+    const datos = resultados.map(item => ({
+      categoria: item.categoria,
+      totalVentas: Number(item.totalVentas),
+    }));
+
+    reson(datos);
+  } catch (error) {
+    console.error("❌ Error al obtener ventas por categoría", error);
+    res.status(500)on({ message: 'Error interno del servidor' });
+  }
+};
diff --git a/backend-nest/src/estadofactura/estadofactura.controller.ts b/backend-nest/src/estadofactura/estadofactura.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..052186e7213ebacbe54e94337b27a5f34ccc5bd7
--- /dev/null
+++ b/backend-nest/src/estadofactura/estadofactura.controller.ts
@@ -0,0 +1,15 @@
+import { EstadoFactura } from '@/models';
+
+export const listarEstadosFactura = async (req, res, next) => {
+  try {
+    const estados = await EstadoFactura.findAll({
+      attributes: ['id', 'nombre'],
+      order: [['id', 'ASC']],
+    });
+
+    res.json(estados);
+  } catch (error) {
+    console.error('❌ Error al listar estados de factura:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/estadofactura/estadofactura.model.ts b/backend-nest/src/estadofactura/estadofactura.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..33c0f639ed526003679fa168fd3e75df76455284
--- /dev/null
+++ b/backend-nest/src/estadofactura/estadofactura.model.ts
@@ -0,0 +1,18 @@
+export default (sequelize, DataTypes) => {
+  const EstadoFactura = sequelize.define('EstadoFactura', {
+    id: { type: DataTypes.INTEGER, primaryKey: true },
+    nombre: { type: DataTypes.STRING, allowNull: false },
+  }, {
+    tableName: 'EstadosFacturas',
+    timestamps: false,
+  });
+
+  EstadoFactura.associate = (models) => {
+    EstadoFactura.hasMany(models.Factura, {
+      foreignKey: 'estadoFacturaId',
+      as: 'facturas',
+    });
+  };
+
+  return EstadoFactura;
+};
diff --git a/backend-nest/src/estadopedido/estadopedido.controller.ts b/backend-nest/src/estadopedido/estadopedido.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..62a84ed159cd59d8f02e2d961c41eb45c0e04ace
--- /dev/null
+++ b/backend-nest/src/estadopedido/estadopedido.controller.ts
@@ -0,0 +1,45 @@
+import { EstadoPedido } from '@/models';
+
+export const listarEstadosPedido = async (req, res, next) => {
+  try {
+    const estados = await EstadoPedido.findAll({ order: [['id', 'ASC']] });
+    res.json(estados);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const crearEstadoPedido = async (req, res, next) => {
+  try {
+    const { nombre, descripcion } = req.body;
+    const nuevo = await EstadoPedido.create({ nombre, descripcion });
+    res.status(201).json(nuevo);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarEstadoPedido = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const { nombre, descripcion } = req.body;
+    const estado = await EstadoPedido.findByPk(id);
+    if (!estado) return res.status(404).json({ mensaje: 'Estado no encontrado' });
+    await estado.update({ nombre, descripcion });
+    res.json(estado);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarEstadoPedido = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const estado = await EstadoPedido.findByPk(id);
+    if (!estado) return res.status(404).json({ mensaje: 'Estado no encontrado' });
+    await estado.destroy();
+    res.json({ mensaje: 'Estado eliminado correctamente' });
+  } catch (error) {
+    next(error);
+  }
+};
diff --git a/backend-nest/src/estadopedido/estadopedido.model.ts b/backend-nest/src/estadopedido/estadopedido.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d762af79b264273f106209cd7c6376acf9579096
--- /dev/null
+++ b/backend-nest/src/estadopedido/estadopedido.model.ts
@@ -0,0 +1,27 @@
+export default (sequelize, DataTypes) => {
+    const EstadoPedido = sequelize.define('EstadoPedido', {
+      nombre: {
+        type: DataTypes.STRING,
+        allowNull: false,
+        unique: true,
+      },
+      descripcion: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+    }, {
+      tableName: 'EstadosPedidos',
+      timestamps: true,
+      paranoid: true,
+    });
+  
+    EstadoPedido.associate = (models) => {
+      EstadoPedido.hasMany(models.Pedido, {
+        foreignKey: 'estadoPedidoId',
+        as: 'pedidos',
+      });
+    };
+  
+    return EstadoPedido;
+  };
+  
\ No newline at end of file
diff --git a/backend-nest/src/factura/factura.controller.ts b/backend-nest/src/factura/factura.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9e13a0cbc245c679ce05817b9703a99d6d031902
--- /dev/null
+++ b/backend-nest/src/factura/factura.controller.ts
@@ -0,0 +1,63 @@
+import { Op } from 'sequelize';
+import { Factura, EstadoFactura } from '@/models';
+
+export const listarFacturas = async (req, res, next) => {
+  try {
+    const {
+      buscar = '',
+      fechaDesde,
+      fechaHasta,
+      estadoFacturaId,
+      pagina = 1,
+      limit = 50,
+    } = req.query;
+
+    const offset = (parseInt(pagina) - 1) * parseInt(limit);
+
+    const where = {};
+
+    if (buscar) {
+      where[Op.or] = [
+        { apellido_razon_soc: { [Op.like]: `%${buscar}%` } },
+        { nombre: { [Op.like]: `%${buscar}%` } },
+        { cuit: { [Op.like]: `%${buscar}%` } },
+      ];
+    }
+
+    if (fechaDesde && fechaHasta) {
+      where.fecha_comp = {
+        [Op.between]: [new Date(fechaDesde), new Date(fechaHasta)],
+      };
+    }
+
+    if (estadoFacturaId) {
+      where.estadoFacturaId = estadoFacturaId;
+    }
+
+    const { count, rows } = await Factura.findAndCountAll({
+      where,
+      limit: parseInt(limit),
+      offset,
+      order: [['fecha_comp', 'DESC']],
+      include: [
+        {
+          model: EstadoFactura,
+          as: 'estado',
+          attributes: ['id', 'nombre'],
+        },
+      ],
+    });
+
+    res.json({
+      data: rows,
+      pagina: parseInt(pagina),
+      totalPaginas: Math.ceil(count / parseInt(limit)),
+      totalItems: count,
+      hasNextPage: offset + rows.length < count,
+      hasPrevPage: offset > 0,
+    });
+  } catch (error) {
+    console.error('❌ Error al listar facturas:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/factura/factura.model.ts b/backend-nest/src/factura/factura.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..d7928fba66642c83124db85fec746ee5db54dcb6
--- /dev/null
+++ b/backend-nest/src/factura/factura.model.ts
@@ -0,0 +1,47 @@
+export default (sequelize, DataTypes) => {
+  const Factura = sequelize.define('Factura', {
+    id: { type: DataTypes.INTEGER, primaryKey: true },
+    id_cliente: DataTypes.INTEGER,
+    id_empresa: DataTypes.INTEGER,
+    nro_pto_vta: DataTypes.STRING,
+    id_personal: DataTypes.INTEGER,
+    id_vendedor: DataTypes.INTEGER,
+    nro_doc: DataTypes.STRING,
+    tipo_comp: DataTypes.STRING,
+    letra_comp: DataTypes.STRING,
+    nro_comp: DataTypes.INTEGER,
+    fecha_comp: DataTypes.DATE,
+    nro_pedido: DataTypes.STRING,
+    total: DataTypes.FLOAT,
+    monto_gravado: DataTypes.FLOAT,
+    monto_iva: DataTypes.FLOAT,
+    apellido_razon_soc: DataTypes.STRING,
+    nombre: DataTypes.STRING,
+    nro_cae_cai: DataTypes.STRING,
+    fecha_vencimiento_cae_cai: DataTypes.DATE,
+    anulada_boolean: DataTypes.BOOLEAN,
+    fecha_registro: DataTypes.DATE,
+    detalles_json: DataTypes.JSON,
+    detalles_cobro_json: DataTypes.JSON,
+    sincronizadoEl: DataTypes.DATE,
+    estadoFacturaId: DataTypes.INTEGER,
+  });
+
+  Factura.associate = (models) => {
+    Factura.belongsTo(models.EstadoFactura, {
+      foreignKey: 'estadoFacturaId',
+      as: 'estado'
+    });
+    Factura.belongsTo(models.PedidoDux, {
+      as: "pedidoDux",
+      foreignKey: "nro_pedido",
+      targetKey: "nro_pedido",
+    });
+    Factura.hasMany(models.DetalleFactura, {
+      foreignKey: 'facturaId',
+      as: 'detalles'
+    });
+  };
+
+  return Factura;
+};
diff --git a/backend-nest/src/graficos/graficos.controller.ts b/backend-nest/src/graficos/graficos.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..1ed27ddb25bca20d5a2132f2e3f7dd6c6a917e7c
--- /dev/null
+++ b/backend-nest/src/graficos/graficos.controller.ts
@@ -0,0 +1,138 @@
+import { ReporteProduccion, Planta } from "@/models";
+import { construirWhere, construirIncludeProducto } from '@/helpers/graficos';
+import dayjs from "dayjs";
+
+// Resumen tabla
+export const obtenerResumenProduccion = async (req, res, next) => {
+  try {
+    const where = construirWhere(req.query);
+    const includeProducto = construirIncludeProducto(req.query);
+    const page = parseInt(req.query.page)||1, limit = parseInt(req.query.limit)||10;
+    const offset = (page-1)*limit;
+    const { count, rows } = await ReporteProduccion.findAndCountAll({
+      where,
+      include: [
+        includeProducto,
+        { model: Planta, as: "planta", attributes: ["nombre"] }
+      ],
+      order:[["fecha","DESC"]],
+      limit, offset,
+      raw:true, nest:true
+    });
+    const items = rows.map(r=>({
+      fecha: r.fecha? dayjs(r.fecha).format("DD/MM/YYYY"):"",
+      planta: r.planta?.nombre||"Sin Planta",
+      categoria: r.producto?.Categoria?.nombre||"Sin Categoría",
+      producto:{ id:r.producto?.id||null, nombre:r.producto?.nombre||"Sin Producto", sku:r.producto?.sku||"Sin SKU" },
+      turno: r.turno||"Sin Turno",
+      cantidad: r.cantidad||0,
+      totalCostoDux: (Number(r.producto?.costoDux)||0)*(r.cantidad||0),
+      totalValor:    (Number(r.producto?.precioUnitario)||0)*(r.cantidad||0)
+    }));
+    res.json({ items, totalItems:count, totalPages:Math.ceil(count/limit), currentPage:page });
+  } catch(e){ next(e) }
+};
+
+// Producción por Planta
+export const obtenerResumenProduccionPorPlanta = async (req,res,next)=>{
+  try{
+    const where = construirWhere(req.query);
+    const includeProducto = construirIncludeProducto(req.query);
+    const rows = await ReporteProduccion.findAll({
+      where,
+      include: [
+        includeProducto,
+        { model: Planta, as: "planta", attributes: ["nombre"] }
+      ],
+      raw:true, nest:true
+    });
+    const resumen = {};
+    rows.forEach(r=>{
+      const key = r.planta?.nombre||"Sin Planta";
+      if(!resumen[key]) resumen[key]={ planta:key, totalCantidad:0, totalCostoDux:0, totalValor:0 };
+      resumen[key].totalCantidad += r.cantidad||0;
+      resumen[key].totalCostoDux += (Number(r.producto?.costoDux)||0)*(r.cantidad||0);
+      resumen[key].totalValor    += (Number(r.producto?.precioUnitario)||0)*(r.cantidad||0);
+    });
+    res.json(Object.values(resumen));
+  }catch(e){ next(e) }
+};
+
+// Producción por Categoría
+export const obtenerResumenProduccionPorCategoria = async (req,res,next)=>{
+  try{
+    const where = construirWhere(req.query);
+    const includeProducto = construirIncludeProducto(req.query);
+    const rows = await ReporteProduccion.findAll({ where, include:[includeProducto], raw:true, nest:true });
+    const resumen = {};
+    rows.forEach(r=>{
+      const key = r.producto?.Categoria?.nombre||"Sin Categoría";
+      if(!resumen[key]) resumen[key]={ categoria:key, totalCantidad:0, totalCostoDux:0, totalValor:0 };
+      resumen[key].totalCantidad += r.cantidad||0;
+      resumen[key].totalCostoDux += (Number(r.producto?.costoDux)||0)*(r.cantidad||0);
+      resumen[key].totalValor    += (Number(r.producto?.precioUnitario)||0)*(r.cantidad||0);
+    });
+    res.json(Object.values(resumen));
+  }catch(e){ next(e) }
+};
+
+// Producción por Turno
+export const obtenerResumenProduccionPorTurno = async (req,res,next)=>{
+  try{
+    const where = construirWhere(req.query);
+    const includeProducto = construirIncludeProducto(req.query);
+    const rows = await ReporteProduccion.findAll({ where, include:[includeProducto], raw:true, nest:true });
+    const resumen = {};
+    rows.forEach(r=>{
+      const key = r.turno||"Sin Turno";
+      if(!resumen[key]) resumen[key]={ turno:key, totalCantidad:0, totalCostoDux:0, totalValor:0 };
+      resumen[key].totalCantidad += r.cantidad||0;
+      resumen[key].totalCostoDux += (Number(r.producto?.costoDux)||0)*(r.cantidad||0);
+      resumen[key].totalValor    += (Number(r.producto?.precioUnitario)||0)*(r.cantidad||0);
+    });
+    res.json(Object.values(resumen));
+  }catch(e){ next(e) }
+};
+
+// Resumen general
+export const obtenerResumenProduccionGeneral = async (req,res,next)=>{
+  try{
+    const where = construirWhere(req.query);
+    const includeProducto = construirIncludeProducto(req.query);
+    const rows = await ReporteProduccion.findAll({ where, include:[includeProducto], raw:true, nest:true });
+    let totalCantidad=0, totalCostoDux=0, totalValor=0;
+    rows.forEach(r=>{
+      totalCantidad += r.cantidad||0;
+      totalCostoDux   += (Number(r.producto?.costoDux)||0)*(r.cantidad||0);
+      totalValor     += (Number(r.producto?.precioUnitario)||0)*(r.cantidad||0);
+    });
+    res.json({ totalCantidad, totalCostoDux, totalValor });
+  }catch(e){ next(e) }
+};
+
+// Evolución
+export const obtenerEvolucionProduccion = async (req,res,next)=>{
+  try{
+    const { desde,hasta,turno,plantaId,categoriaId,producto } = req.query;
+    if(!desde||!hasta) return res.status(400).json({ mensaje:"Fechas requeridas" });
+    const where = construirWhere({ desde,hasta,turno,plantaId });
+    const includeProducto = construirIncludeProducto({ categoriaId,producto });
+    const rows = await ReporteProduccion.findAll({
+      where,
+      include:[includeProducto],
+      attributes:["fecha","cantidad"],
+      raw:true, nest:true
+    });
+    const start = dayjs(desde), end = dayjs(hasta), diff = end.diff(start,"day");
+    const fmt = diff<=31?"DD/MM/YYYY":diff<=62?"[Semana] WW/YYYY":"MM/YYYY";
+    const agg = {};
+    rows.forEach(r=>{
+      const key = fmt.includes("Semana")? dayjs(r.fecha).format("[Semana] WW/YYYY"): dayjs(r.fecha).format(fmt);
+      if(!agg[key]) agg[key]={ totalCantidad:0, totalValor:0 };
+      agg[key].totalCantidad += r.cantidad||0;
+      agg[key].totalValor    += (Number(r.producto.precioUnitario)||0)*(r.cantidad||0);
+    });
+    const resultado = Object.entries(agg).map(([periodo,d])=>({ periodo, totalCantidad:d.totalCantidad, totalValor:d.totalValor }));
+    res.json(resultado);
+  }catch(e){ next(e) }
+};
diff --git a/backend-nest/src/historialcliente/historialcliente.model.ts b/backend-nest/src/historialcliente/historialcliente.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..f2dc352ad65fb3c75d12d60910acf19f21bf18b1
--- /dev/null
+++ b/backend-nest/src/historialcliente/historialcliente.model.ts
@@ -0,0 +1,36 @@
+export default (sequelize, DataTypes) => {
+    const HistorialCliente = sequelize.define('HistorialCliente', {
+      campo: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+      valorAnterior: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+      valorNuevo: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+      clienteId: {
+        type: DataTypes.INTEGER,
+        allowNull: false,
+      },
+      usuarioId: {
+        type: DataTypes.INTEGER,
+        allowNull: true,
+      },
+    }, {
+      tableName: 'HistorialClientes',
+      timestamps: true,
+      paranoid: true,
+    });
+  
+    HistorialCliente.associate = (models) => {
+      HistorialCliente.belongsTo(models.Cliente, { foreignKey: 'clienteId', as: 'cliente' });
+      HistorialCliente.belongsTo(models.Usuario, { foreignKey: 'usuarioId', as: 'usuario' });
+    };
+  
+    return HistorialCliente;
+  };
+  
\ No newline at end of file
diff --git a/backend-nest/src/historialsincronizacion/historialsincronizacion.model.ts 
b/backend-nest/src/historialsincronizacion/historialsincronizacion.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3de1633fc9b2a047d591f5d7f3aa3c999acc5c73
--- /dev/null
+++ b/backend-nest/src/historialsincronizacion/historialsincronizacion.model.ts
@@ -0,0 +1,17 @@
+export default (sequelize, DataTypes) => {
+  const HistorialSincronizacion = sequelize.define("HistorialSincronizacion", {
+    tipo: {
+      type: DataTypes.STRING,
+      primaryKey: true,
+    },
+    fechaUltima: {
+      type: DataTypes.DATEONLY,
+      allowNull: false,
+    },
+  }, {
+    tableName: "HistorialSincronizacion",
+    timestamps: false,
+  });
+
+  return HistorialSincronizacion;
+};
diff --git a/backend-nest/src/imagenproducto/imagenproducto.model.ts b/backend-nest/src/imagenproducto/imagenproducto.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..d99c54e1d5a522623f9bdc299bf98eba1493abb4
--- /dev/null
+++ b/backend-nest/src/imagenproducto/imagenproducto.model.ts
@@ -0,0 +1,25 @@
+export default (sequelize, DataTypes) => {
+  const ImagenProducto = sequelize.define('ImagenProducto', {
+    url: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    productoId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+    },
+    orden: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+      defaultValue: 0,
+    },
+  });
+
+  ImagenProducto.associate = (models) => {
+    ImagenProducto.belongsTo(models.Producto, {
+      foreignKey: 'productoId',
+    });
+  };
+
+  return ImagenProducto;
+};
diff --git a/backend-nest/src/informesemanal/informesemanal.controller.ts b/backend-nest/src/informesemanal/informesemanal.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3e5987bb9ee9f8b2273a565c64570ad7384d671a
--- /dev/null
+++ b/backend-nest/src/informesemanal/informesemanal.controller.ts
@@ -0,0 +1,272 @@
+import dayjs from 'dayjs';
+import 'dayjs/locale/es.js';
+dayjs.locale('es');
+
+import { format } from 'date-fns';
+import { es } from 'date-fns/locale';
+import { ReporteProduccion, Producto, Categoria } from '@/models';
+import { contarFeriadosEnRango } from '@/helpers/feriados';
+import { Op } from 'sequelize';
+
+export async function obtenerInformeSemanalEnVivo(req, res, next) {
+  try {
+    const hoy = dayjs();
+    const inicioSemana = hoy.startOf('week').add(1, 'day');
+    const hoyFecha = hoy.endOf('day');
+    const diasTranscurridos = hoy.diff(inicioSemana, 'day') + 1;
+    const inicioSemanaPasada = inicioSemana.subtract(7, 'days');
+    const finHastaHoySemanaPasada = inicioSemanaPasada.add(diasTranscurridos - 1, 'day').endOf('day');
+
+    const produccionSemana = await ReporteProduccion.findAll({
+      where: { fecha: { [Op.between]: [inicioSemana.toDate(), hoyFecha.toDate()] } },
+      include: [
+        {
+          model: Producto,
+          as: 'producto',
+          attributes: ['id', 'nombre', 'sku', 'precioUnitario', 'costoDux'],
+          include: {
+            model: Categoria,
+            as: 'Categoria',
+            attributes: ['nombre'],
+          },
+        },
+      ],
+      raw: true,
+      nest: true,
+    });
+
+    const produccionSemanaPasada = await ReporteProduccion.findAll({
+      where: { fecha: { [Op.between]: [inicioSemanaPasada.toDate(), finHastaHoySemanaPasada.toDate()] } },
+      raw: true,
+    });
+
+    const totalSemana = produccionSemana.reduce((acc, r) => acc + (r.cantidad || 0), 0);
+    const totalSemanaPasada = produccionSemanaPasada.reduce((acc, r) => acc + (r.cantidad || 0), 0);
+    const variacionGeneral = totalSemanaPasada > 0 ? ((totalSemana - totalSemanaPasada) / totalSemanaPasada) * 100 : 0;
+
+    const produccionPorDia = {};
+    for (const r of produccionSemana) {
+      const dia = format(new Date(r.fecha), 'EEEE', { locale: es });
+      produccionPorDia[dia] = (produccionPorDia[dia] || 0) + (r.cantidad || 0);
+    }
+    const diaTop = Object.entries(produccionPorDia).sort((a, b) => b[1] - a[1])[0];
+
+    const produccionPorProducto = {};
+    const resumenPorCategoria = {};
+    for (const r of produccionSemana) {
+      const prod = r.producto?.nombre || 'Sin nombre';
+      const cat = r.producto?.Categoria?.nombre || 'Sin categoría';
+      const cant = r.cantidad || 0;
+      const venta = cant * (r.producto?.precioUnitario || 0);
+      const costo = cant * (r.producto?.costoDux || 0);
+
+      if (!produccionPorProducto[prod]) produccionPorProducto[prod] = { unidades: 0, venta: 0, costo: 0 };
+      produccionPorProducto[prod].unidades += cant;
+      produccionPorProducto[prod].venta += venta;
+      produccionPorProducto[prod].costo += costo;
+
+      if (!resumenPorCategoria[cat]) resumenPorCategoria[cat] = { unidades: 0, venta: 0, costo: 0 };
+      resumenPorCategoria[cat].unidades += cant;
+      resumenPorCategoria[cat].venta += venta;
+      resumenPorCategoria[cat].costo += costo;
+    }
+
+    const topProductos = Object.entries(produccionPorProducto)
+      .sort((a, b) => b[1].unidades - a[1].unidades)
+      .slice(0, 10);
+
+    const diasConProduccion = [...new Set(produccionSemana.map(p => format(new Date(p.fecha), 'EEEE', { locale: es })))]
+    const feriados = await contarFeriadosEnRango(inicioSemana.toISOString(), hoyFecha.toISOString());
+    const feriadoTexto = feriados.length > 0
+      ? `📅 Durante el período analizado se identificaron ${feriados.length} día(s) no laborables: ${feriados.map(f => `${f.dia}/${f.mes} 
(${f.motivo})`).join(', ')}.`
+      : null;
+
+    const inicioMes = hoy.startOf('month');
+    const diasDelMes = hoy.daysInMonth();
+    const diasTranscurridosMes = hoy.diff(inicioMes, 'day') + 1;
+
+    const produccionMesActual = await ReporteProduccion.sum('cantidad', {
+      where: { fecha: { [Op.between]: [inicioMes.toDate(), hoy.toDate()] } },
+    }) || 0;
+
+    const promedioDiario = produccionMesActual / diasTranscurridosMes;
+    const proyeccionFinMes = Math.round(promedioDiario * diasDelMes);
+
+    const inicioMesAnterior = hoy.subtract(1, 'month').startOf('month');
+    const finMesAnterior = inicioMesAnterior.endOf('month');
+    const produccionMesAnterior = await ReporteProduccion.sum('cantidad', {
+      where: { fecha: { [Op.between]: [inicioMesAnterior.toDate(), finMesAnterior.toDate()] } },
+    }) || 0;
+
+    const variacionMes = produccionMesAnterior > 0 ? ((produccionMesActual - produccionMesAnterior) / produccionMesAnterior) * 100 : 0;
+
+    const ultimosTresMeses = await Promise.all([...Array(3)].map(async (_, i) => {
+      const inicio = hoy.subtract(i + 1, 'month').startOf('month');
+      const fin = inicio.endOf('month');
+      const total = await ReporteProduccion.sum('cantidad', {
+        where: { fecha: { [Op.between]: [inicio.toDate(), fin.toDate()] } },
+      }) || 0;
+      return { nombre: format(inicio.toDate(), 'MMMM', { locale: es }), total };
+    }));
+
+    const promedioTrimestre = ultimosTresMeses.reduce((acc, m) => acc + m.total, 0) / 3;
+    const tendenciaGeneral = promedioTrimestre > 0 ? ((produccionMesActual - promedioTrimestre) / promedioTrimestre) * 100 : 0;
+
+    const diaActualSemana = hoy.format('dddd');
+
+    const parcialSemanaActual = await ReporteProduccion.sum('cantidad', {
+      where: {
+        fecha: {
+          [Op.between]: [inicioSemana.toDate(), hoy.toDate()],
+        },
+      },
+    }) || 0;
+
+    const finDiaSemanaPasada = inicioSemanaPasada.add(diasTranscurridos - 1, 'day').endOf('day').toDate();
+    const parcialSemanaAnterior = await ReporteProduccion.sum('cantidad', {
+      where: {
+        fecha: {
+          [Op.between]: [inicioSemanaPasada.toDate(), finDiaSemanaPasada],
+        },
+      },
+    }) || 0;
+
+    const produccionUltimas4Semanas = await Promise.all(
+      [...Array(4)].map(async (_, i) => {
+        const inicio = inicioSemana.subtract((i + 1) * 7, 'day').toDate();
+        const fin = dayjs(inicio).add(6, 'day').endOf('day').toDate();
+        const total = await ReporteProduccion.sum('cantidad', {
+          where: { fecha: { [Op.between]: [inicio, fin] } },
+        }) || 0;
+        return total;
+      })
+    );
+
+    const mesActualNombre = format(hoy.toDate(), 'MMMM', { locale: es });
+    const fechaHoyFormateada = format(new Date(), 'dd/MM/yyyy');
+
+    const resumen = `
+Desde el lunes hasta hoy, la producción total alcanzó las ${totalSemana.toLocaleString()} unidades, 
+lo que representa una ${variacionGeneral >= 0 ? 'suba' : 'baja'} del ${Math.abs(variacionGeneral).toFixed(2)}% 
+en comparación con el mismo período de la semana anterior (${totalSemanaPasada.toLocaleString()} unidades).
+
+El día de mayor actividad fue el ${diaTop?.[0] || '-'}, con ${diaTop?.[1]?.toLocaleString() || 0} unidades fabricadas.
+
+📦 Categorías más destacadas:
+${Object.entries(resumenPorCategoria).map(([cat, val]) =>
+  `• ${cat}: ${val.unidades.toLocaleString()} unidades, $${val.venta.toLocaleString()} venta, $${val.costo.toLocaleString()} costo.`).join('\n')}
+
+🏷️ Top 10 productos fabricados:
+${topProductos.map(([nombre, val], i) =>
+  `${i + 1}. ${nombre}: ${val.unidades.toLocaleString()} unidades, $${val.venta.toLocaleString()} venta, $${val.costo.toLocaleString()} 
costo.`).join('\n')}
+
+📈 Producción mensual acumulada (${mesActualNombre}): ${produccionMesActual.toLocaleString()} unidades 
+(${variacionMes >= 0 ? '+' : '-'}${Math.abs(variacionMes).toFixed(2)}% vs mes anterior). 
+Proyección de cierre: ${proyeccionFinMes.toLocaleString()} unidades.
+
+📊 Tendencia trimestral: ${tendenciaGeneral >= 0 ? 'positiva' : 'negativa'} del ${Math.abs(tendenciaGeneral).toFixed(2)}%.
+
+📆 Comparativa intersemanal:
+Entre el lunes y el ${diaActualSemana}, se registraron ${parcialSemanaActual.toLocaleString()} unidades,
+frente a las ${parcialSemanaAnterior.toLocaleString()} que se habían fabricado en el mismo período de la semana anterior.
+
+📅 Producción de las últimas semanas:
+- Semana -4: ${produccionUltimas4Semanas[3].toLocaleString()} unidades
+- Semana -3: ${produccionUltimas4Semanas[2].toLocaleString()} unidades
+- Semana -2: ${produccionUltimas4Semanas[1].toLocaleString()} unidades
+- Semana pasada: ${produccionUltimas4Semanas[0].toLocaleString()} unidades
+- Semana actual (hasta hoy): ${parcialSemanaActual.toLocaleString()} unidades
+
+🕒 Informe actualizado al ${fechaHoyFormateada}.
+${feriadoTexto ? '\n\n' + feriadoTexto : ''}`.trim();
+
+    res.json({
+      resumen,
+      variacion: variacionGeneral,
+      feriados: feriados.length > 0
+    });
+
+  } catch (error) {
+    console.error(error);
+    next(error);
+  }
+}
+
+
+
+export async function generarInformeSemanalFinalizado(req, res, next) {
+  try {
+    const inicioSemana = dayjs().startOf('week').add(1, 'day').subtract(7, 'days');
+    const finSemana = inicioSemana.add(6, 'days');
+
+    const reportes = await ReporteProduccion.findAll({
+      where: { fecha: { [Op.between]: [inicioSemana.toDate(), finSemana.toDate()] } },
+      include: [
+        {
+          model: Producto,
+          as: "producto",
+          attributes: ["nombre", "sku"],
+          include: {
+            model: Categoria,
+            as: "Categoria",
+            attributes: ["nombre"],
+          },
+        },
+      ],
+      raw: true,
+      nest: true,
+    });
+
+    const total = reportes.reduce((acc, r) => acc + (r.cantidad || 0), 0);
+
+    const categoriasResumen = {};
+    for (const r of reportes) {
+      const cat = r.producto?.Categoria?.nombre || "Sin Categoría";
+      if (!categoriasResumen[cat]) categoriasResumen[cat] = 0;
+      categoriasResumen[cat] += r.cantidad || 0;
+    }
+
+    const productosResumen = {};
+    for (const r of reportes) {
+      const key = `${r.producto?.sku} - ${r.producto?.nombre}`;
+      if (!productosResumen[key]) productosResumen[key] = 0;
+      productosResumen[key] += r.cantidad || 0;
+    }
+
+    const topProductos = Object.entries(productosResumen)
+      .sort((a, b) => b[1] - a[1])
+      .slice(0, 10);
+
+    const feriados = await contarFeriadosEnRango(inicioSemana.toISOString(), finSemana.toISOString());
+    const feriadoTexto = feriados.length > 0
+      ? `Hubo ${feriados.length} día(s) no laborable(s) (${feriados.map(f => `${f.dia}/${f.mes}`).join(", ")}).`
+      : "No hubo feriados esta semana.";
+
+    const fechaInicioTexto = format(inicioSemana.toDate(), "dd/MM/yyyy", { locale: es });
+    const fechaFinTexto = format(finSemana.toDate(), "dd/MM/yyyy", { locale: es });
+
+    let resumen = `✅ Informe Semanal (${fechaInicioTexto} al ${fechaFinTexto})\n\n`;
+    resumen += `Se produjeron **${total.toLocaleString()} unidades** en total.\n\n`;
+    resumen += `**Detalle por Categoría:**\n`;
+    for (const [cat, cantidad] of Object.entries(categoriasResumen)) {
+      resumen += `- ${cat}: ${cantidad.toLocaleString()} unidades.\n`;
+    }
+    resumen += `\n**Top 10 Productos más producidos:**\n`;
+    for (const [prod, cantidad] of Object.entries(topProductos)) {
+      resumen += `- ${prod[0]}: ${prod[1].toLocaleString()} unidades.\n`;
+    }
+    resumen += `\n${feriadoTexto}`;
+
+    await InformeSemanal.create({
+      fechaInicio: inicioSemana.toDate(),
+      fechaFin: finSemana.toDate(),
+      resumen,
+    });
+
+    res.json({ mensaje: "Informe semanal generado y guardado exitosamente." });
+
+  } catch (error) {
+    console.error(error);
+    next(error);
+  }
+}
diff --git a/backend-nest/src/informesemanal/informesemanal.model.ts b/backend-nest/src/informesemanal/informesemanal.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..00a91241bd2f02388cb22b7eeaa11efb0d5b6ed6
--- /dev/null
+++ b/backend-nest/src/informesemanal/informesemanal.model.ts
@@ -0,0 +1,27 @@
+export default (sequelize, DataTypes) => {
+    const InformeSemanal = sequelize.define('InformeSemanal', {
+        id: {
+            type: DataTypes.INTEGER,
+            autoIncrement: true,
+            primaryKey: true,
+        },
+        fechaInicio: {
+            type: DataTypes.DATEONLY,
+            allowNull: false,
+        },
+        fechaFin: {
+            type: DataTypes.DATEONLY,
+            allowNull: false,
+        },
+        resumen: {
+            type: DataTypes.TEXT,
+            allowNull: false,
+        },
+    }, {
+        tableName: "InformesSemanales",
+        timestamps: true,
+    });
+
+    return InformeSemanal;
+
+};
\ No newline at end of file
diff --git a/backend-nest/src/ipcliente/ipcliente.controller.ts b/backend-nest/src/ipcliente/ipcliente.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e0c878b43f46919f69f28e83341299065ade93b2
--- /dev/null
+++ b/backend-nest/src/ipcliente/ipcliente.controller.ts
@@ -0,0 +1,10 @@
+import { IpClienteCliente } from '@/models';
+
+export const vincularIpConCliente = async (ipClienteId, clienteId) => {
+  const yaExiste = await IpClienteCliente.findOne({ where: { ipClienteId, clienteId } });
+
+  if (!yaExiste) {
+    await IpClienteCliente.create({ ipClienteId, clienteId });
+    console.log(`✅ IP ${ipClienteId} vinculada al cliente ${clienteId}`);
+  }
+};
diff --git a/backend-nest/src/ipcliente/ipcliente.model.ts b/backend-nest/src/ipcliente/ipcliente.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..c51a740b8b2538caf486197b2017a2b15183de69
--- /dev/null
+++ b/backend-nest/src/ipcliente/ipcliente.model.ts
@@ -0,0 +1,32 @@
+export default (sequelize, DataTypes) => {
+  const IpCliente = sequelize.define('IpCliente', {
+    ip: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    clienteId: {
+      type: DataTypes.INTEGER.UNSIGNED,
+      allowNull: true,
+    },
+  }, {
+    tableName: 'IpClientes',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  IpCliente.associate = (models) => {
+    IpCliente.belongsToMany(models.Cliente, {
+      through: models.IpClienteCliente,
+      foreignKey: 'ipClienteId',
+      otherKey: 'clienteId',
+      as: 'clientes',
+    });
+
+    IpCliente.hasMany(models.LogCliente, {
+      foreignKey: 'ipClienteId',
+      as: 'logs',
+    });
+  };
+
+  return IpCliente;
+};
diff --git a/backend-nest/src/ipclientecliente/ipclientecliente.model.ts b/backend-nest/src/ipclientecliente/ipclientecliente.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..7e8905f173eec9fd6e0ba7fc1549daab070acd23
--- /dev/null
+++ b/backend-nest/src/ipclientecliente/ipclientecliente.model.ts
@@ -0,0 +1,25 @@
+export default (sequelize, DataTypes) => {
+  const IpClienteCliente = sequelize.define('IpClienteCliente', {
+    ipClienteId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'IpClientes',
+        key: 'id',
+      },
+    },
+    clienteId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Clientes',
+        key: 'id',
+      },
+    },
+  }, {
+    tableName: 'IpClienteCliente',
+    timestamps: false,
+  });
+
+  return IpClienteCliente;
+};
diff --git a/backend-nest/src/listaprecio/listaprecio.model.ts b/backend-nest/src/listaprecio/listaprecio.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b5c67f238e704ef28c5e07bbd6d0ed67608363aa
--- /dev/null
+++ b/backend-nest/src/listaprecio/listaprecio.model.ts
@@ -0,0 +1,29 @@
+export default (sequelize, DataTypes) => {
+  const ListaPrecio = sequelize.define('ListaPrecio', {
+    nombre: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    descripcion: {
+      type: DataTypes.TEXT,
+      allowNull: true,
+    },
+    activa: {
+      type: DataTypes.BOOLEAN,
+      defaultValue: true,
+    },
+  }, {
+    tableName: 'ListasPrecio',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  ListaPrecio.associate = (models) => {
+    ListaPrecio.hasMany(models.ListaPrecioProducto, {
+      foreignKey: 'listaPrecioId',
+      as: 'productos',
+    });
+  };
+
+  return ListaPrecio;
+};
diff --git a/backend-nest/src/listaprecioproducto/listaprecioproducto.model.ts b/backend-nest/src/listaprecioproducto/listaprecioproducto.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c242df26648d284711dab82111587f01eaa2a56c
--- /dev/null
+++ b/backend-nest/src/listaprecioproducto/listaprecioproducto.model.ts
@@ -0,0 +1,32 @@
+export default (sequelize, DataTypes) => {
+  const ListaPrecioProducto = sequelize.define('ListaPrecioProducto', {
+    productoId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Productos',
+        key: 'id',
+      },
+    },
+    listaPrecioId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+    },
+    precio: {
+      type: DataTypes.DECIMAL(10, 2),
+      allowNull: false,
+    },
+  }, {
+    tableName: 'ListaPrecioProductos',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  ListaPrecioProducto.associate = (models) => {
+    ListaPrecioProducto.belongsTo(models.Producto, {
+      foreignKey: 'productoId',
+    });
+  };
+
+  return ListaPrecioProducto;
+};
diff --git a/backend-nest/src/localidad/localidad.model.ts b/backend-nest/src/localidad/localidad.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..8400fd339db75b8ab942c62a35afa7a0df6d1af1
--- /dev/null
+++ b/backend-nest/src/localidad/localidad.model.ts
@@ -0,0 +1,38 @@
+export default (sequelize, DataTypes) => {
+  const Localidad = sequelize.define('Localidad', {
+    nombre: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    provinciaId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+      references: {
+        model: 'Provincia',
+        key: 'id',
+      },
+    },
+    codigoPostal: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+  }, {
+    sequelize,
+    modelName: 'Localidad',
+    tableName: 'Localidades',
+    timestamps: false,
+    paranoid: false,
+  });
+
+  Localidad.associate = (models) => {
+    Localidad.belongsTo(models.Provincia, {
+      foreignKey: 'provinciaId',
+      as: 'provincia'
+    });
+    Localidad.hasMany(models.Cliente, {
+      foreignKey: 'localidadId'
+    });
+  };
+
+  return Localidad;
+};
diff --git a/backend-nest/src/logauditoria/logauditoria.model.ts b/backend-nest/src/logauditoria/logauditoria.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..48fb71409ce7cc24fdb6ff4bb4b3bd4e1342683a
--- /dev/null
+++ b/backend-nest/src/logauditoria/logauditoria.model.ts
@@ -0,0 +1,49 @@
+  export default (sequelize, DataTypes) => {
+    const LogAuditoria = sequelize.define('LogAuditoria', {
+      tabla: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+      accion: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+      registroId: {
+        type: DataTypes.INTEGER,
+        allowNull: true,
+      },
+      usuarioId: {
+        type: DataTypes.INTEGER,
+        allowNull: true,
+      },
+      descripcion: {
+        type: DataTypes.TEXT,
+        allowNull: true,
+      },
+      datosAntes: {
+        type: DataTypes.JSON,
+        allowNull: true,
+      },
+      datosDespues: {
+        type: DataTypes.JSON,
+        allowNull: true,
+      },
+      ip: {
+        type: DataTypes.STRING(45),
+        allowNull: true,
+      },
+    }, {
+      tableName: 'LogAuditoria',
+      timestamps: true,
+    });
+
+    LogAuditoria.associate = (models) => {
+      LogAuditoria.belongsTo(models.Usuario, {
+        foreignKey: 'usuarioId',
+        as: 'usuario',
+      });
+    };
+    
+    return LogAuditoria;
+  };
+  
\ No newline at end of file
diff --git a/backend-nest/src/logcliente/logcliente.controller.ts b/backend-nest/src/logcliente/logcliente.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..1a634bf070d31b4f2277bb7b1b5e107f178b0c72
--- /dev/null
+++ b/backend-nest/src/logcliente/logcliente.controller.ts
@@ -0,0 +1,134 @@
+import { LogCliente, IpCliente, Cliente, Categoria } from '@/models';
+import { Op } from 'sequelize';
+import { getClientIp } from '@/utils/getClientIp';
+import dayjs from 'dayjs';
+
+export const registrarLogCliente = async (req, res, next) => {
+  try {
+    const ip = getClientIp(req);
+    const {
+      categoriaId = null,
+      busqueda = null,
+      tiempoEnPantalla = null,
+      ubicacion = null,
+      sesion = null,
+      referer = null,
+      fuente = null,
+    } = req.body;
+
+    const ipCliente = await IpCliente.findOne({ where: { ip } });
+    const ipClienteId = ipCliente?.id || null;
+
+    if (!ipClienteId && !busqueda && !categoriaId) {
+      return res.status(400)on({ message: 'Faltan datos o IP no registrada' });
+    }
+
+    const log = await LogCliente.create({
+      ipClienteId,
+      categoriaId,
+      busqueda,
+      tiempoEnPantalla,
+      ubicacion,
+      sesion,
+      referer,
+      fuente,
+    });
+
+    res.status(201)on({ message: 'Log registrado', log });
+  } catch (error) {
+    console.error('❌ Error al registrar log del cliente:', error);
+    next(error);
+  }
+};
+
+export const listarLogsCliente = async (req, res, next) => {
+  try {
+    const {
+      clienteId,
+      ip,
+      desde,
+      hasta,
+      limit = 100,
+      page = 1,
+      groupBy,
+    } = req.query;
+
+    const offset = (page - 1) * limit;
+    const where = {};
+
+    const include = [
+      {
+        model: IpCliente,
+        as: 'ipCliente',
+        required: false,
+        attributes: ['ip'],
+        include: [
+          {
+            model: Cliente,
+            as: 'clientes',
+            attributes: ['id', 'nombre'],
+            through: { attributes: [] }, // no mostrar datos de la tabla pivot
+            required: false,
+          }
+        ],
+      },
+      {
+        model: Categoria,
+        as: 'categoria',
+        attributes: ['id', 'nombre'],
+        required: false,
+      },
+    ];
+
+    // ✅ Filtro por fecha
+    if (desde && hasta) {
+      where.createdAt = {
+        [Op.between]: [new Date(desde), new Date(hasta)],
+      };
+    }
+
+    // ✅ NO filtramos por IP ni clienteId aquí. Vamos a filtrar luego.
+    const paginando = groupBy !== 'ipFecha';
+
+    const { count, rows } = await LogCliente.findAndCountAll({
+      where,
+      include,
+      order: [['createdAt', 'DESC']],
+      ...(paginando && { limit: Number(limit), offset }),
+    });
+    // ✅ Filtro manual por clienteId si viene
+    const filtrados = clienteId
+      ? rows.filter((log) => {
+          const ipCliente = log.ipCliente;
+          const cliente = ipCliente?.cliente;
+          return (
+            cliente?.id == clienteId || ipCliente?.clienteId == clienteId
+          );
+        })
+      : rows;
+
+    // ✅ Agrupado por IP y fecha
+    if (groupBy === 'ipFecha') {
+      const grouped = filtrados.reduce((acc, log) => {
+        const fecha = dayjs(log.createdAt).format('YYYY-MM-DD');
+        const ip = log.ipCliente?.ip || 'Sin IP';
+        const key = `${ip} - ${fecha}`;
+        acc[key] = acc[key] || [];
+        acc[key].push(log);
+        return acc;
+      }, {});
+      return reson({ grouped });
+    }
+
+    return reson({
+      data: filtrados,
+      total: filtrados.length,
+      pagina: Number(page),
+      totalPaginas: Math.ceil(filtrados.length / limit),
+    });
+  } catch (error) {
+    console.error('❌ Error al listar logs:', error);
+    next(error);
+  }
+};
+
diff --git a/backend-nest/src/logcliente/logcliente.model.ts b/backend-nest/src/logcliente/logcliente.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..3dfa7f3e3b6e9e51d812e1fc50dd8810de304161
--- /dev/null
+++ b/backend-nest/src/logcliente/logcliente.model.ts
@@ -0,0 +1,53 @@
+export default (sequelize, DataTypes) => {
+  const LogCliente = sequelize.define('LogCliente', {
+    categoriaId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    },
+    busqueda: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    tiempoEnPantalla: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    },
+    ubicacion: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    sesion: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    referer: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    fuente: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    ipClienteId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    },
+  }, {
+    paranoid: true,
+    timestamps: true,
+    tableName: 'LogClientes',
+  });
+
+  LogCliente.associate = (models) => {
+    LogCliente.belongsTo(models.IpCliente, {
+      foreignKey: 'ipClienteId',
+      as: 'ipCliente',
+    });
+    LogCliente.belongsTo(models.Categoria, {
+      foreignKey: 'categoriaId',
+      as: 'categoria',
+    });
+  };
+
+  return LogCliente;
+};
diff --git a/backend-nest/src/main.ts b/backend-nest/src/main.ts
new file mode 100644
index 0000000000000000000000000000000000000000..13cad38cff92aa3b3d3ef6232306e450cadf5713
--- /dev/null
+++ b/backend-nest/src/main.ts
@@ -0,0 +1,8 @@
+import { NestFactory } from '@nestjs/core';
+import { AppModule } from './app.module';
+
+async function bootstrap() {
+  const app = await NestFactory.create(AppModule);
+  await app.listen(3000);
+}
+bootstrap();
diff --git a/backend-nest/src/marca/marca.model.ts b/backend-nest/src/marca/marca.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..eade77d56e36844f1ea2f9ae56f0bf9b3a21916e
--- /dev/null
+++ b/backend-nest/src/marca/marca.model.ts
@@ -0,0 +1,21 @@
+export default (sequelize, DataTypes) => {
+  const Marca = sequelize.define('Marca', {
+    nombre: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+  }, {
+    tableName: 'Marcas',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  Marca.associate = (models) => {
+    Marca.hasMany(models.Producto, {
+      foreignKey: 'marcaId',
+      as: 'Productos',
+    });
+  };
+
+  return Marca;
+};
diff --git a/backend-nest/src/mensajeautomatico/mensajeautomatico.model.ts b/backend-nest/src/mensajeautomatico/mensajeautomatico.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..128f870d13f988cdb4a32d3e4e521abb76d5b902
--- /dev/null
+++ b/backend-nest/src/mensajeautomatico/mensajeautomatico.model.ts
@@ -0,0 +1,44 @@
+export default (sequelize, DataTypes) => {
+  const MensajeAutomatico = sequelize.define('MensajeAutomatico', {
+    clienteId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+    },
+    tipo: {
+      type: DataTypes.ENUM('inactivo_inicial', 'inactivo_recordatorio'),
+      allowNull: false,
+    },
+    fechaEnvio: {
+      type: DataTypes.DATE,
+      allowNull: false,
+      defaultValue: DataTypes.NOW,
+    },
+    respuestaCliente: {
+    type: DataTypes.TEXT,
+    allowNull: true,
+    },
+    estado: {
+    type: DataTypes.ENUM('pendiente', 'respondido', 'interesado', 'cancelado'),
+    defaultValue: 'pendiente',
+    }
+
+  }, {
+    tableName: 'MensajesAutomaticos',
+    timestamps: false,
+    indexes: [
+      {
+        unique: true,
+        fields: ['clienteId', 'tipo'],
+      },
+    ],
+  });
+
+  MensajeAutomatico.associate = (models) => {
+    MensajeAutomatico.belongsTo(models.Cliente, {
+      foreignKey: 'clienteId',
+      as: 'cliente',
+    });
+  };
+
+  return MensajeAutomatico;
+};
diff --git a/backend-nest/src/models/index.ts b/backend-nest/src/models/index.ts
new file mode 100755
index 0000000000000000000000000000000000000000..4d04d3d52f570789badb6ca2c6e1796eacc0e1a7
--- /dev/null
+++ b/backend-nest/src/models/index.ts
@@ -0,0 +1,105 @@
+import { Sequelize, DataTypes } from 'sequelize';
+import fs from 'fs';
+import path from 'path';
+import { fileURLToPath, pathToFileURL } from 'url';
+import dotenv from 'dotenv';
+
+dotenv.config();
+
+const __filename = fileURLToPath(import.meta.url);
+const __dirname = path.dirname(__filename);
+
+const sequelize = new Sequelize(
+  process.env.DB_NAME,
+  process.env.DB_USER,
+  process.env.DB_PASSWORD,
+  {
+    host: process.env.DB_HOST,
+    port: process.env.DB_PORT,
+    dialect: process.env.DB_DIALECT || 'mysql',
+    logging: false,
+    define: {
+      timestamps: true,
+      paranoid: true,
+    },
+  }
+);
+
+const db = {};
+
+// Cargar modelos dinámicamente con import() (ES Modules)
+// Recursively gather all compiled model files (ending with .model.js)
+function getModelFiles(dir: string): string[] {
+  return fs.readdirSync(dir, { withFileTypes: true }).flatMap((entry) => {
+    const resolved = path.join(dir, entry.name);
+    if (entry.isDirectory()) {
+      return getModelFiles(resolved);
+    }
+    return entry.isFile() && resolved.endsWith('.model.js') ? [resolved] : [];
+  });
+}
+
+const modelsDir = path.join(__dirname, '..');
+const files = getModelFiles(modelsDir);
+
+await Promise.all(
+  files.map(async (file) => {
+    const modulePath = pathToFileURL(file).href;
+    const { default: modelDef } = await import(modulePath);
+    const model = modelDef(sequelize, DataTypes);
+    db[model.name] = model;
+  })
+);
+
+// Asociaciones
+Object.values(db).forEach(model => {
+  if (model.associate) {
+    model.associate(db);
+  }
+});
+
+db.sequelize = sequelize;
+db.Sequelize = Sequelize;
+
+// Exportación por default (db) y nombrada (modelos individuales)
+export default db;
+
+export const {
+  Categoria,
+  Producto,
+  ImagenProducto,
+  Cliente,
+  Pedido,
+  DetallePedido,
+  Usuario,
+  Pagina,
+  Banner,
+  Provincia,
+  Localidad,
+  IpCliente,
+  LogCliente,
+  LogAuditoria,
+  Notificacion,
+  HistorialCliente,
+  IpClienteCliente,
+  ReporteProduccion,
+  Planta,
+  RolUsuario,
+  EstadoPedido,
+  PermisosUsuario,
+  Modulo,
+  InformeSemanal,
+  Marca,
+  ListaPrecio,
+  ListaPrecioProducto,
+  ConversacionBot,
+  MensajeAutomatico,
+  PedidoDux,
+  Factura,
+  EstadoFactura,
+  DetallePedidoDux,
+  DetalleFactura,
+  HistorialSincronizacion
+} = db;
+
+export { sequelize, Sequelize };
diff --git a/backend-nest/src/modulo/modulo.model.ts b/backend-nest/src/modulo/modulo.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ce54fa7bd63e50fe94ca4b9d43f8b6ca72f0d197
--- /dev/null
+++ b/backend-nest/src/modulo/modulo.model.ts
@@ -0,0 +1,29 @@
+export default (sequelize, DataTypes) => {
+    const Modulo = sequelize.define('Modulo', {
+      nombre: {
+        type: DataTypes.STRING(100),
+        allowNull: false,
+        unique: true
+      },
+      descripcion: {
+        type: DataTypes.TEXT,
+        allowNull: true
+      },
+      createdAt: DataTypes.DATE,
+      updatedAt: DataTypes.DATE,
+      deletedAt: DataTypes.DATE
+    }, {
+      tableName: 'Modulos',
+      timestamps: true,
+      paranoid: true
+    });
+  
+    Modulo.associate = (models) => {
+      Modulo.hasMany(models.PermisosUsuario, {
+        foreignKey: 'moduloId'
+      });
+    };
+  
+    return Modulo;
+  };
+  
\ No newline at end of file
diff --git a/backend-nest/src/notificacion/notificacion.controller.ts b/backend-nest/src/notificacion/notificacion.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c28d0c23abef5d264573ab3b22a7d6d89c5c3af7
--- /dev/null
+++ b/backend-nest/src/notificacion/notificacion.controller.ts
@@ -0,0 +1,78 @@
+import { Notificacion } from '@/models';
+import { Op } from 'sequelize';
+
+export const obtenerNotificaciones = async (req, res, next) => {
+  try {
+    const usuarioId = req.usuario?.id;
+
+    const notificaciones = await Notificacion.findAll({
+      where: {
+        [Op.or]: [
+          { usuarioId },
+          { usuarioId: null },
+        ],
+      },
+      order: [['createdAt', 'DESC']],
+      limit: 100,
+      attributes: ['id', 'titulo', 'mensaje', 'leida', 'createdAt', 'pedidoId'] // ✅ importante
+    });
+
+    res.json(notificaciones);
+  } catch (error) {
+    console.error('❌ Error al obtener notificaciones:', error);
+    next(error);
+  }
+};
+
+export const marcarComoLeida = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const notificacion = await Notificacion.findByPk(id);
+
+    if (!notificacion) return res.status(404).json({ message: 'Notificación no encontrada' });
+
+    await notificacion.update({ leida: true });
+    res.json({ message: 'Notificación marcada como leída' });
+  } catch (error) {
+    console.error('❌ Error al marcar como leída:', error);
+    next(error);
+  }
+};
+
+export const eliminarNotificacion = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const notificacion = await Notificacion.findByPk(id);
+
+    if (!notificacion) return res.status(404).json({ message: 'Notificación no encontrada' });
+
+    await notificacion.destroy();
+    res.json({ message: 'Notificación eliminada' });
+  } catch (error) {
+    console.error('❌ Error al eliminar notificación:', error);
+    next(error);
+  }
+};
+
+export const crearNotificacion = async (req, res, next) => {
+  try {
+    const { mensaje, titulo, tipo, usuarioId = null, pedidoId = null } = req.body;
+
+    if (!mensaje || !titulo) {
+      return res.status(400).json({ message: 'Faltan campos obligatorios' });
+    }
+
+    const notificacion = await Notificacion.create({
+      mensaje,
+      titulo,
+      tipo,
+      usuarioId,
+      pedidoId,
+    });
+
+    res.status(201).json({ message: 'Notificación creada', notificacion });
+  } catch (error) {
+    console.error('❌ Error al crear notificación:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/notificacion/notificacion.model.ts b/backend-nest/src/notificacion/notificacion.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..3a45580f280d68ea6694c5a631863a52117b22e6
--- /dev/null
+++ b/backend-nest/src/notificacion/notificacion.model.ts
@@ -0,0 +1,52 @@
+export default (sequelize, DataTypes) => {
+  const Notificacion = sequelize.define('Notificacion', {
+    titulo: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    mensaje: {
+      type: DataTypes.TEXT,
+      allowNull: false,
+    },
+    leida: {
+      type: DataTypes.BOOLEAN,
+      defaultValue: false,
+    },
+    tipo: {
+      type: DataTypes.STRING,
+      defaultValue: 'general',
+    },
+    readAt: {
+      type: DataTypes.DATE,
+      allowNull: true,
+    },
+    pedidoId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    },
+    usuarioId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    }
+  }, {
+    tableName: 'Notificaciones',
+    timestamps: true,
+  });
+
+  Notificacion.associate = (models) => {
+    Notificacion.belongsTo(models.Usuario, {
+      as: 'usuario',
+      foreignKey: 'usuarioId',
+      onDelete: 'SET NULL',
+      onUpdate: 'CASCADE'
+    });
+    Notificacion.belongsTo(models.Pedido, {
+      as: 'pedido',
+      foreignKey: 'pedidoId',
+      onDelete: 'SET NULL',
+      onUpdate: 'CASCADE',
+    });
+  };
+
+  return Notificacion;
+};
diff --git a/backend-nest/src/pagina/pagina.controller.ts b/backend-nest/src/pagina/pagina.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..24b5a3181a49c6e124deeeff2b80aa7cc8ae6d17
--- /dev/null
+++ b/backend-nest/src/pagina/pagina.controller.ts
@@ -0,0 +1,155 @@
+import { Pagina, Banner } from '@/models';
+import path from 'path';
+import cache from '@/utils/cache';
+import { crearAuditoria } from '@/utils/auditoria';
+
+export const obtenerPagina = async (req, res, next) => {
+  try {
+    const cacheKey = 'pagina';
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    let pagina = await Pagina.findOne({
+      include: [{ model: Banner, as: 'Banners' }],
+    });
+
+    if (!pagina) {
+      pagina = await Pagina.create({ logo: '' });
+    }
+
+    cache.set(cacheKey, pagina);
+    reson(pagina);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarPagina = async (req, res, next) => {
+  try {
+    const pagina = await Pagina.findOne();
+    if (!pagina) return res.status(404)on({ message: 'Datos de página no encontrados' });
+
+    await pagina.update(req.body);
+
+    cache.del('pagina');
+    reson(pagina);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const subirLogo = async (req, res, next) => {
+  try {
+    const pagina = await Pagina.findOne();
+    if (!pagina) return res.status(404)on({ message: 'Datos de página no encontrados' });
+
+    if (!req.file) return res.status(400)on({ message: 'No se recibió ningún archivo' });
+
+    pagina.logo = `/uploads/logo/${req.file.filename}`;
+    await pagina.save();
+    
+    cache.del('pagina');
+    reson({ message: 'Logo actualizado correctamente', logo: pagina.logo });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const listarBanners = async (req, res, next) => {
+  try {
+    const cacheKey = 'bannersActivos';
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    const banners = await Banner.findAll({ order: [['orden', 'ASC']] });
+    cache.set(cacheKey, banners);
+    reson(banners);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const crearBanner = async (req, res, next) => {
+  try {
+    const { orden, fechaInicio, fechaFin } = req.body;
+    if (!req.file || !orden) {
+      return res.status(400)on({ message: 'La imagen y el orden son obligatorios' });
+    }
+
+    const pagina = await Pagina.findOne();
+    if (!pagina) return res.status(404)on({ message: 'No se encontró la página' });
+
+    const imagen = `/uploads/banners/${req.file.filename}`;
+
+    const banner = await Banner.create({
+      imagen,
+      orden,
+      fechaInicio: fechaInicio || null,
+      fechaFin: fechaFin || null,
+      paginaId: pagina.id,
+    });
+    
+    await crearAuditoria({
+      tabla: 'banners',
+      accion: 'crea banner',
+      registroId: banner.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se creó un banner`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+    
+
+    cache.del('bannersActivos');
+    res.status(201)on({ message: 'Banner creado correctamente', banner });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarBanner = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const banner = await Banner.findByPk(id);
+    if (!banner) return res.status(404)on({ message: 'Banner no encontrado' });
+
+    await banner.update(req.body);
+    
+    await crearAuditoria({
+      tabla: 'banners',
+      accion: 'actualiza banner',
+      registroId: banner.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se actualizó el banner`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    cache.del('bannersActivos');
+    reson({ message: 'Banner actualizado correctamente', banner });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarBanner = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const banner = await Banner.findByPk(id);
+    if (!banner) return res.status(404)on({ message: 'Banner no encontrado' });
+
+    await banner.destroy();
+    
+    await crearAuditoria({
+      tabla: 'banners',
+      accion: 'elimina banner',
+      registroId: banner.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se eliminó el banner`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    cache.del('bannersActivos');
+    reson({ message: 'Banner eliminado correctamente' });
+  } catch (error) {
+    next(error);
+  }
+};
\ No newline at end of file
diff --git a/backend-nest/src/pagina/pagina.model.ts b/backend-nest/src/pagina/pagina.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..6485dcddfb06ca68242c6ac1b48563e17ff9863b
--- /dev/null
+++ b/backend-nest/src/pagina/pagina.model.ts
@@ -0,0 +1,20 @@
+export default (sequelize, DataTypes) => {
+  const Pagina = sequelize.define(
+    'Pagina',
+    {
+      logo: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+    },
+    {
+      freezeTableName: true, // 👈 esto evita la pluralización
+    }
+  );
+
+  Pagina.associate = (models) => {
+    Pagina.hasMany(models.Banner, { foreignKey: 'paginaId', as: 'Banners' });
+  };
+
+  return Pagina;
+};
diff --git a/backend-nest/src/pedido/pedido.controller.ts b/backend-nest/src/pedido/pedido.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..21d94bbd213a69f30248dd5edefc7a9e5935e707
--- /dev/null
+++ b/backend-nest/src/pedido/pedido.controller.ts
@@ -0,0 +1,553 @@
+import { Pedido, DetallePedido, Producto, Cliente, Usuario, Notificacion, EstadoPedido, PedidoDux } from '@/models';
+import { ESTADOS_PEDIDO } from '@/constants/estadosPedidos';
+import { ROLES_USUARIOS } from '@/constants/rolesUsuarios';
+import { DATOS_EMPRESA_DUX } from '@/constants/datosEmpresaDux';
+import { Op } from 'sequelize';
+import { enviarEmailPedido } from "@/utils/notificaciones/email";
+import { enviarWhatsappPedido } from "@/utils/notificaciones/whatsapp";
+import { crearClienteConGeocodificacion } from '@/helpers/clientes';
+import { crearAuditoria } from '@/utils/auditoria';
+
+export const obtenerPedidos = async (req, res, next) => {
+  try {
+    const {
+      pagina = 1,
+      limit = 10,
+      orden = 'createdAt',
+      direccion = 'DESC',
+      busqueda = '',
+      vendedorId: vendedorIdQuery,
+      estado,
+      desde,
+      hasta,
+    } = req.query;
+
+    const offset = (pagina - 1) * limit;
+
+    // 💡 Filtros dinámicos
+    const where = {};
+
+    // ⏱️ Filtro por fecha
+    if (desde && hasta) {
+      where.createdAt = {
+        [Op.between]: [new Date(desde), new Date(hasta)],
+      };
+    }
+
+    // ✅ Si es VENDEDOR logueado, filtrar por SU ID
+    if (req.usuario?.rolUsuarioId === ROLES_USUARIOS.VENDEDOR) {
+      where.usuarioId = req.usuario.id;
+    }
+
+    // ✅ Si en query viene vendedorId (y el usuario NO es vendedor) filtramos por ese
+    if (vendedorIdQuery && req.usuario?.rolUsuarioId !== ROLES_USUARIOS.VENDEDOR) {
+      where.usuarioId = vendedorIdQuery;
+    }
+
+    if (estado) {
+      where.estadoPedidoId = estado;
+    }
+
+    const whereCliente = busqueda
+      ? { nombre: { [Op.like]: `%${busqueda}%` } }
+      : undefined;
+
+    const orderBy = (() => {
+      if (orden === 'cliente') return [[{ model: Cliente, as: 'cliente' }, 'nombre', direccion]];
+      if (orden === 'vendedor') return [[{ model: Usuario, as: 'usuario' }, 'nombre', direccion]];
+      return [[orden, direccion]];
+    })();
+
+    // 🥇 Primero paginamos solo los IDs
+    const idsPaginados = await Pedido.findAll({
+      attributes: ['id'],
+      where,
+      include: [
+        { model: Cliente, as: 'cliente', where: whereCliente, required: !!busqueda },
+      ],
+      limit: Number(limit),
+      offset,
+      order: orderBy,
+      subQuery: false,
+    });
+
+    const ids = idsPaginados.map((p) => p.id);
+
+    // 🥈 Traemos los datos completos
+    const pedidos = await Pedido.findAll({
+      where: { id: ids },
+      include: [
+        { model: Cliente, as: 'cliente', required: true },
+        { model: Usuario, as: 'usuario' },
+        { model: DetallePedido, as: 'detalles', include: [{ model: Producto, as: 'producto' }] },
+        { model: EstadoPedido, as: 'estadoPedido' },
+      ],
+      order: orderBy,
+    });
+
+    const count = await Pedido.count({
+      where,
+      include: [
+        { model: Cliente, as: 'cliente', where: whereCliente, required: !!busqueda },
+      ],
+      distinct: true,
+      col: 'id',
+    });
+
+    const totalPaginas = Math.ceil(count / limit);
+
+    reson({
+      data: pedidos,
+      pagina: Number(pagina),
+      totalPaginas,
+      totalItems: count,
+      hasNextPage: Number(pagina) < totalPaginas,
+      hasPrevPage: Number(pagina) > 1,
+    });
+  } catch (error) {
+    console.error('❌ ERROR en obtenerPedidos:', error);
+    next(error);
+  }
+};
+
+export const actualizarEstadoPedido = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const { estadoPedidoId } = req.body;
+
+    if (isNaN(id)) {
+      return res.status(400)on({ message: 'ID inválido' });
+    }
+
+    const pedido = await Pedido.findByPk(id, {
+      include: [
+        { model: Cliente, as: 'cliente' },
+        { model: Usuario, as: 'usuario' },
+        {
+          model: DetallePedido,
+          as: 'detalles',
+          include: [{ model: Producto, as: 'producto' }],
+        },
+      ],
+    });
+    if (!pedido) {
+      return res.status(404)on({ message: 'Pedido no encontrado' });
+    }
+
+    if (pedido.estadoEdicion === true) {
+      return res.status(409)on({
+        message: 'El pedido está siendo editado por el cliente. No se puede cambiar el estado hasta que finalice la edición.',
+      });
+    }
+
+    const estadoPedido = await EstadoPedido.findByPk(estadoPedidoId);
+    if (!estadoPedido) {
+      return res.status(400)on({ message: 'Estado de pedido no válido' });
+    }
+
+    const estadoAnteriorId = pedido.estadoPedidoId;
+    const estadoAnterior = await EstadoPedido.findByPk(estadoAnteriorId);
+    await pedido.update({ estadoPedidoId });
+
+    const estadoNombre = estadoPedido.nombre;
+    const tituloBase = estadoNombre === 'Cancelado' ? 'Pedido cancelado' : 'Pedido actualizado';
+    const mensajeBase = estadoNombre === 'Cancelado'
+      ? `El pedido #${pedido.id} ha sido cancelado.`
+      : `El estado del pedido #${pedido.id} ahora es "${estadoNombre}".`;
+
+    if (pedido.usuarioId) {
+      await Notificacion.create({
+        titulo: tituloBase,
+        mensaje: mensajeBase,
+        tipo: 'pedido',
+        usuarioId: pedido.usuarioId,
+        pedidoId: pedido.id,
+      });
+    }
+
+    const admins = await Usuario.findAll({
+      where: { rolUsuarioId: { [Op.in]: [ROLES_USUARIOS.SUPREMO, ROLES_USUARIOS.ADMINISTRADOR] } },
+    });
+
+    for (const admin of admins) {
+      await Notificacion.create({
+        titulo: tituloBase,
+        mensaje: mensajeBase,
+        tipo: 'pedido',
+        usuarioId: admin.id,
+        pedidoId: pedido.id,
+      });
+    }
+
+    // ✅ Envío de email y WhatsApp
+    try {
+      const cliente = pedido.cliente;
+      const vendedor = pedido.usuario;
+      const carrito = pedido.detalles?.map((d) => ({
+        id: d.productoId,
+        nombre: d.producto?.nombre || 'Producto sin nombre',
+        cantidad: d.cantidad,
+        precioUnitario: d.precioUnitario,
+        unidadPorBulto: d.unidadPorBulto,
+        precioPorBulto: d.precioPorBulto,
+        subtotal: d.subtotal,
+      })) || [];
+
+      if (estadoNombre === 'Cancelado') {
+        await enviarWhatsappCancelacion({ cliente, pedido, vendedor });
+        await enviarEmailCancelacion({ cliente, pedido, vendedor });
+      } else {
+        await enviarWhatsappCambioEstadoPedido({ cliente, pedido, estadoNombre });
+        await enviarEmailCambioEstado({ cliente, pedido, estadoNombre, vendedor });
+      }
+      
+    } catch (notiError) {
+      console.warn("❌ Error al enviar WhatsApp/email en cambio de estado:", notiError.message);
+    }
+
+    await crearAuditoria({
+      tabla: 'pedidos',
+      accion: 'actualiza estado',
+      registroId: pedido.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Pedido ${pedido.id} actualizado a estado "${estadoNombre}".`,
+      datosAntes: { estadoPedidoId: estadoAnteriorId },
+      datosDespues: { estadoPedidoId },
+      ip: req.ip,
+    });
+
+    reson({
+      message: 'Estado del pedido actualizado correctamente',
+      estadoPedidoId,
+      estadoNombre,
+    });
+
+  } catch (error) {
+    console.error('❌ Error al actualizar estado del pedido:', error);
+    next(error);
+  }
+};
+
+export const crearPedidoDesdePanel = async (req, res, next) => {
+  try {
+    const { cliente, carrito, usuarioId } = req.body;
+
+    if (!cliente || !Array.isArray(carrito) || carrito.length === 0) {
+      return res.status(400)on({ error: 'Datos incompletos para el pedido.' });
+    }
+
+    // Crear cliente si no existe
+    let clienteFinal = null;
+
+    if (!cliente.id || cliente.id === 0) {
+      clienteFinal = await crearClienteConGeocodificacion(cliente, usuarioId);
+    } else {
+      const buscado = await Cliente.findByPk(cliente.id);
+      if (!buscado) {
+        return res.status(404)on({ error: 'Cliente no encontrado.' });
+      }
+      clienteFinal = buscado;
+    }
+
+    // Estado por defecto (Recibido o Pendiente)
+    const estadoPedidoId = 1; // ID de "Recibido", según tu tabla
+
+    // Crear el pedido
+    const pedido = await Pedido.create({
+      clienteId: clienteFinal.id,
+      usuarioId,
+      total: 0,
+      estadoPedidoId,
+    });
+
+    let total = 0;
+
+    for (const item of carrito) {
+      const productoDb = await Producto.findByPk(item.id);
+      if (!productoDb) continue;
+
+      const precioUnitario = productoDb.precioUnitario;
+      const precioPorBulto = productoDb.precioPorBulto || precioUnitario;
+      const subtotal = item.cantidad * precioPorBulto;
+
+      await DetallePedido.create({
+        pedidoId: pedido.id,
+        clienteId: clienteFinal.id,
+        productoId: item.id,
+        cantidad: item.cantidad,
+        precioUnitario,
+        unidadPorBulto,
+        precioPorBulto: precioPorBulto,
+        subtotal,
+        dispositivo: 'panel',
+        usuarioId,
+      });
+
+      total += subtotal;
+    }
+
+    await pedido.update({ total });
+
+    const vendedor = usuarioId ? await Usuario.findByPk(usuarioId) : null;
+
+    // Notificación al vendedor
+    await Notificacion.create({
+      titulo: 'Nuevo pedido creado desde el panel',
+      mensaje: `El cliente ${clienteFinal.nombre} tiene un nuevo pedido.`,
+      tipo: 'pedido',
+      usuarioId,
+    });
+
+    // Notificaciones a administradores
+    const admins = await Usuario.findAll({
+      where: { rolUsuarioId: { [Op.in]: [1, 2] } }, // supremo y administrador
+    });
+
+    for (const admin of admins) {
+      await Notificacion.create({
+        titulo: 'Pedido desde el panel',
+        mensaje: `El cliente ${clienteFinal.nombre} tiene un nuevo pedido.`,
+        tipo: 'pedido',
+        usuarioId: admin.id,
+      });
+    }
+
+    // Envío por email y WhatsApp
+    await enviarEmailPedido({ cliente: clienteFinal, pedido, carrito, vendedor });
+    await enviarWhatsappPedido({ cliente: clienteFinal, pedido, carrito, vendedor });
+    
+    
+    await crearAuditoria({
+      tabla: 'pedidos',
+      accion: 'crea pedido desde panel',
+      registroId: pedido.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Pedido ${pedido.id} creado desde el panel por ${req.usuario?.nombre || 'sistema'}.`,
+      datosAntes: {},
+      datosDespues: { clienteId: clienteFinal.id, total },
+      ip: req.ip,
+    });
+    
+    res.status(201)on({ message: 'Pedido creado correctamente', pedidoId: pedido.id });
+  } catch (err) {
+    console.error('❌ Error al crear pedido desde panel:', err);
+    res.status(500)on({ error: 'Error interno al crear el pedido.' });
+  }
+};
+
+export const validarCarritoSolo = async (req, res, next) => {
+  try {
+    const { carrito } = req.body;
+
+    if (!Array.isArray(carrito) || carrito.length === 0) {
+      return res.status(400)on({ message: 'Carrito vacío' });
+    }
+
+    const detalles = [];
+    let total = 0;
+
+    for (const item of carrito) {
+      const productoDb = await Producto.findByPk(item.id);
+      if (!productoDb) continue;
+
+      const precioUnitario = productoDb.precioUnitario;
+      const precioPorBulto = productoDb.precioPorBulto || precioUnitario;
+      const subtotal = item.cantidad * precioPorBulto;
+
+      detalles.push({
+        productoId: item.id,
+        nombre: productoDb.nombre,
+        cantidad: item.cantidad,
+        precioUnitario,
+        precioPorBulto,
+        subtotal,
+      });
+
+      total += subtotal;
+    }
+
+    reson({ detalles, total });
+  } catch (error) {
+    console.error('❌ Error al validar carrito:', error);
+    next(error);
+  }
+};
+
+export const obtenerPedidoPorId = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    if (isNaN(id)) return res.status(400)on({ message: 'ID inválido' });
+
+    const pedido = await Pedido.findByPk(id, {
+      include: [
+        {
+          model: DetallePedido,
+          as: 'detalles',
+          include: [{ model: Producto, as: 'producto' }],
+        },
+        { model: Cliente, as: 'cliente' },
+        { model: Usuario, as: 'usuario' },
+        { model: EstadoPedido, as: 'estadoPedido' }, // ✅ agregado
+      ],
+    });
+
+    if (!pedido) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+    reson(pedido);
+  } catch (error) {
+    console.error('❌ Error en obtenerPedidoPorId:', error);
+    next(error);
+  }
+};
+
+export const obtenerPedidosInicio = async (req, res, next) => {
+  try {
+    const { vendedorId: vendedorIdQuery } = req.query;
+
+    const wherePedido = {};
+
+    // Si el logueado es vendedor, filtra por su propio usuarioId
+    if (req.usuario?.rolUsuarioId === ROLES_USUARIOS.VENDEDOR) {
+      wherePedido.usuarioId = req.usuario.id;
+    }
+
+    // Si en query mandan vendedorId (ej: admin quiere ver otro vendedor)
+    if (vendedorIdQuery && req.usuario?.rolUsuarioId !== ROLES_USUARIOS.VENDEDOR) {
+      wherePedido.usuarioId = vendedorIdQuery;
+    }
+
+    const pendientes = await Pedido.findAll({
+      where: {
+        ...wherePedido,
+        estadoPedidoId: ESTADOS_PEDIDO.PENDIENTE,
+      },
+      include: [
+        { model: Cliente, as: "cliente" },
+        { model: EstadoPedido, as: "estadoPedido" },
+      ],
+      order: [["createdAt", "DESC"]],
+      limit: 5,
+    });
+
+    const confirmados = await Pedido.findAll({
+      where: {
+        ...wherePedido,
+        estadoPedidoId: {
+          [Op.in]: [ESTADOS_PEDIDO.CONFIRMADO, ESTADOS_PEDIDO.PREPARANDO],
+        },
+      },
+      include: [
+        { model: Cliente, as: "cliente" },
+        { model: EstadoPedido, as: "estadoPedido" },
+      ],
+      order: [["createdAt", "DESC"]],
+      limit: 5,
+    });
+
+    reson({ pendientes, confirmados });
+  } catch (error) {
+    console.error("❌ Error al obtener pedidos de inicio:", error);
+    next(error);
+  }
+};
+
+export const enviarPedidoADux = async (req, res, next) => {
+  const API_KEY = process.env.DUX_API_KEY;
+  try {
+    const { id } = req.params;
+
+    const pedido = await Pedido.findByPk(id, {
+      include: [
+        {
+          model: DetallePedido,
+          as: 'detalles',
+          include: [{ model: Producto, as: 'producto' }],
+        },
+        { model: Cliente, as: 'cliente' },
+        { model: Usuario, as: 'usuario' },
+      ],
+    });
+
+    if (!pedido) {
+      return res.status(404)on({ message: 'Pedido no encontrado' });
+    }
+
+    if (!pedido.detalles || pedido.detalles.length === 0) {
+      return res.status(400)on({ message: 'El pedido no tiene detalles cargados.' });
+    }
+
+    const payload = {
+      fecha: new Date(pedido.createdAt)
+        .toLocaleDateString('es-AR')
+        .replaceAll('/', ''),
+      id_empresa: DATOS_EMPRESA_DUX.id_empresa,
+      id_sucursal_empresa: DATOS_EMPRESA_DUX.id_sucursal_empresa,
+      apellido_razon_social: pedido.cliente?.razonSocial || 'Sin nombre',
+      categoria_fiscal: 'CONSUMIDOR_FINAL',
+      productos: pedido.detalles.map((d) => {
+        if (!d.producto?.sku) {
+          throw new Error(`El producto "${d.producto?.nombre}" no tiene SKU`);
+        }
+        return {
+          cod_item: d.producto.sku,
+          ctd: d.cantidad,
+          precio: d.precioUnitario,
+        };
+      }),
+    };
+
+    await axios.post(
+      'https://erp.duxsoftware.com.ar/WSERP/rest/services/pedido/nuevopedido',
+      payload,
+      {
+        headers: {
+          Authorization: `Bearer ${API_KEY}`,
+          'Content-Type': 'application/json',
+        },
+      }
+    );
+
+    await pedido.update({ estadoPedidoId: ESTADOS_PEDIDO.PREPARANDO });
+
+    await crearAuditoria({
+      tabla: 'pedidos',
+      accion: 'envia a Dux',
+      registroId: pedido.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Pedido ${pedido.id} enviado a Dux y actualizado a estado PREPARANDO`,
+      datosAntes: { estadoPedidoId: pedido.estadoPedidoId },
+      datosDespues: { estadoPedidoId: ESTADOS_PEDIDO.PREPARANDO },
+      ip: req.ip,
+    });
+
+    reson({ message: 'Pedido enviado a Dux correctamente.' });
+  } catch (error) {
+    console.error('❌ Error al enviar pedido a Dux:', error);
+    next(error);
+  }
+};
+
+export const listarPedidosDux = async (req, res, next) => {
+  try {
+    const { pagina = 1, limit = 50 } = req.query;
+    const offset = (parseInt(pagina) - 1) * parseInt(limit);
+
+    const { count, rows } = await PedidoDux.findAndCountAll({
+      limit: parseInt(limit),
+      offset,
+      order: [['fecha', 'DESC']],
+    });
+
+    reson({
+      data: rows,
+      pagina: parseInt(pagina),
+      totalPaginas: Math.ceil(count / parseInt(limit)),
+      totalItems: count,
+      hasNextPage: offset + rows.length < count,
+      hasPrevPage: offset > 0,
+    });
+  } catch (error) {
+    console.error('❌ Error al listar pedidos Dux:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/pedido/pedido.model.ts b/backend-nest/src/pedido/pedido.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..1def44ae31804725ed0681365eb72afd33519a6e
--- /dev/null
+++ b/backend-nest/src/pedido/pedido.model.ts
@@ -0,0 +1,73 @@
+export default (sequelize, DataTypes) => {
+  const Pedido = sequelize.define('Pedido', {
+    id: {
+      type: DataTypes.INTEGER,
+      autoIncrement: true,
+      primaryKey: true
+    },
+    observaciones: {
+      type: DataTypes.TEXT,
+      allowNull: true,
+    },
+    total: {
+      type: DataTypes.FLOAT,
+      allowNull: false,
+    },
+    clienteId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Clientes',
+        key: 'id',
+      },
+    },
+    usuarioId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+      references: {
+        model: 'Usuarios',
+        key: 'id',
+      }
+    },
+    estadoEdicion: {
+      type: DataTypes.BOOLEAN,
+      allowNull: false,
+      defaultValue: false,
+    },    
+    estadoPedidoId: {
+      type: DataTypes.INTEGER.UNSIGNED,
+      allowNull: false,
+      references: {
+        model: 'EstadosPedidos',
+        key: 'id',
+      },
+    },
+  });
+
+  Pedido.associate = (models) => {
+    Pedido.belongsTo(models.Cliente, {
+      foreignKey: 'clienteId',
+      as: 'cliente',
+      onDelete: 'SET NULL',
+      onUpdate: 'CASCADE'
+    });
+    Pedido.belongsTo(models.Usuario, {
+      as: 'usuario',
+      foreignKey: 'usuarioId',
+      onDelete: 'SET NULL',
+      onUpdate: 'CASCADE'
+    });
+    Pedido.hasMany(models.DetallePedido, {
+      foreignKey: 'pedidoId',
+      as: 'detalles',
+      onDelete: 'CASCADE',
+      onUpdate: 'CASCADE'
+    });
+    Pedido.belongsTo(models.EstadoPedido, {
+      foreignKey: 'estadoPedidoId',
+      as: 'estadoPedido',
+    });
+  };
+
+  return Pedido;
+};
diff --git a/backend-nest/src/pedidodux/pedidodux.model.ts b/backend-nest/src/pedidodux/pedidodux.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..c9c41bb7d387ff5b5cbeabb5fe4d88f60205af5d
--- /dev/null
+++ b/backend-nest/src/pedidodux/pedidodux.model.ts
@@ -0,0 +1,48 @@
+export default (sequelize, DataTypes) => {
+  const PedidoDux = sequelize.define('PedidoDux', {
+    id: {
+      type: DataTypes.INTEGER,
+      autoIncrement: true,
+      primaryKey: true,
+    },
+    nro_pedido: {
+      type: DataTypes.INTEGER,
+      unique: true,
+      allowNull: false,
+    },
+    cliente: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    personal: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    fecha: {
+      type: DataTypes.DATE,
+      allowNull: false,
+    },
+    total: {
+      type: DataTypes.DECIMAL(12, 3),
+      allowNull: false,
+    },
+    estado_facturacion: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    observaciones: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    detalles: {
+      type: DataTypes.JSON,
+      allowNull: true,
+    }
+    }, {
+    tableName: 'PedidosDux',
+    timestamps: true,
+    paranoid: true
+  });
+
+  return PedidoDux;
+};
\ No newline at end of file
diff --git a/backend-nest/src/permisosusuario/permisosusuario.model.ts b/backend-nest/src/permisosusuario/permisosusuario.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..b56df2df0f6cd006fe2520bcbc112d2c79908a04
--- /dev/null
+++ b/backend-nest/src/permisosusuario/permisosusuario.model.ts
@@ -0,0 +1,49 @@
+export default (sequelize, DataTypes) => {
+    const PermisosUsuario = sequelize.define('PermisosUsuario', {
+      rolUsuarioId: {
+        type: DataTypes.INTEGER.UNSIGNED,
+        allowNull: false
+      },
+      moduloId: {
+        type: DataTypes.INTEGER.UNSIGNED,
+        allowNull: false
+      },
+      accion: {
+        type: DataTypes.STRING(50),
+        allowNull: false
+      },
+      permitido: {
+        type: DataTypes.BOOLEAN,
+        allowNull: false,
+        defaultValue: false
+      },
+      createdAt: DataTypes.DATE,
+      updatedAt: DataTypes.DATE,
+      deletedAt: DataTypes.DATE
+    }, {
+      tableName: 'PermisosUsuarios',
+      timestamps: true,
+      paranoid: true,
+      indexes: [
+        {
+          unique: true,
+          fields: ['rolUsuarioId', 'moduloId', 'accion']
+        }
+      ]
+    });
+  
+    PermisosUsuario.associate = (models) => {
+      PermisosUsuario.belongsTo(models.RolUsuario, {
+        foreignKey: 'rolUsuarioId',
+        as: 'rolUsuario'
+      });
+  
+      PermisosUsuario.belongsTo(models.Modulo, {
+        foreignKey: 'moduloId',
+        as: 'modulo'
+      });
+    };
+  
+    return PermisosUsuario;
+  };
+  
\ No newline at end of file
diff --git a/backend-nest/src/planta/planta.controller.ts b/backend-nest/src/planta/planta.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..24cd86425f84f314e610be06060bff8630142ba9
--- /dev/null
+++ b/backend-nest/src/planta/planta.controller.ts
@@ -0,0 +1,13 @@
+import { Planta } from "@/models";
+
+export const obtenerPlantas = async (req, res, next) => {
+  try {
+    const plantas = await Planta.findAll({
+      attributes: ["id", "nombre", "direccion"],
+      order: [["nombre", "ASC"]],
+    });
+    res.json(plantas);
+  } catch (error) {
+    next(error);
+  }
+};
diff --git a/backend-nest/src/planta/planta.model.ts b/backend-nest/src/planta/planta.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..213c7c4225cb6057df73788a9751b5430514d56f
--- /dev/null
+++ b/backend-nest/src/planta/planta.model.ts
@@ -0,0 +1,27 @@
+export default (sequelize, DataTypes) => {
+    const Planta = sequelize.define('Planta', {
+      nombre: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+      direccion: {
+        type: DataTypes.STRING,
+        allowNull: false,
+      },
+    }, {
+      tableName: 'Plantas',
+      timestamps: true,
+      paranoid: true,
+    });
+  
+    Planta.associate = (models) => {
+      Planta.hasMany(models.ReporteProduccion, {
+        foreignKey: "plantaId",
+        as: "reportes",
+      });
+    };
+    
+  
+    return Planta;
+  };
+  
\ No newline at end of file
diff --git a/backend-nest/src/producto/producto.controller.ts b/backend-nest/src/producto/producto.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..edad9efd9a637000dd0c8ea913a739fd625bd810
--- /dev/null
+++ b/backend-nest/src/producto/producto.controller.ts
@@ -0,0 +1,508 @@
+import { Producto, Categoria, ImagenProducto, ListaPrecioProducto } from '@/models';
+import { Op, Sequelize } from 'sequelize';
+import { leerExcelProductos } from '@/utils/leerExcel';
+import cache from '@/utils/cache';
+import { crearAuditoria } from '@/utils/auditoria';
+
+export const obtenerProductos = async (req, res, next) => {
+  try {
+    const {
+      page = 1,
+      limit = 20,
+      orden = 'sku',
+      direccion = 'ASC',
+      buscar = '',
+      categoriaId,
+      listaPrecioId,
+    } = req.query;
+
+    const offset = (page - 1) * limit;
+    const where = {};
+    const include = [
+      {
+        model: ImagenProducto,
+        as: 'Imagenes',
+        required: false,
+        attributes: ['id', 'url', 'orden'],
+        separate: true,
+        order: [['orden', 'ASC']],
+      }
+    ];
+    
+    if (buscar) {
+      include.push({
+        model: Categoria,
+        as: 'Categoria',
+        required: false,
+        where: {
+          nombre: { [Op.like]: `%${buscar}%` },
+        },
+      });
+    
+      where[Op.or] = [
+        { nombre: { [Op.like]: `%${buscar}%` } },
+        { sku: { [Op.like]: `%${buscar}%` } },
+      ];
+    } else {
+      include.push({
+        model: Categoria,
+        as: 'Categoria',
+        required: false,
+      });
+      if (listaPrecioId) {
+        include.push({
+          model: ListaPrecioProducto,
+          as: 'listasPrecio',
+          required: true,
+          where: { listaPrecioId },
+        });
+      }
+    }
+
+    if (categoriaId) {
+      where.categoriaId = categoriaId;
+    } else {
+      where.categoriaId = { [Op.notIn]: [11, 12] };
+    }
+
+    where.precioUnitario = { [Op.gt]: 0 };
+
+    const { count, rows } = await Producto.findAndCountAll({
+      where,
+      include,
+      offset,
+      limit: Number(limit),
+      order: [[orden, direccion]],
+    });
+
+    const totalPaginas = Math.ceil(count / limit);
+
+    reson({
+      data: rows,
+      pagina: Number(page),
+      totalPaginas,
+      totalItems: count,
+      hasNextPage: Number(page) < totalPaginas,
+      hasPrevPage: Number(page) > 1,
+    });
+  } catch (error) {
+    console.error('❌ Error al obtener productos:', error);
+    next(error);
+  }
+};
+
+export const obtenerProductosProduccion = async (req, res, next) => {
+  try {
+    const {
+      page = 1,
+      limit = 20,
+      orden = 'sku',
+      direccion = 'ASC',
+      buscar = '',
+      categoriaId,
+      listaPrecioId,
+    } = req.query;
+
+    const offset = (page - 1) * limit;
+    const where = {};
+    const include = [
+      {
+        model: ImagenProducto,
+        as: 'Imagenes',
+        required: false,
+        attributes: ['id', 'url', 'orden'],
+        separate: true,
+        order: [['orden', 'ASC']],
+      }
+    ];
+    
+    if (buscar) {
+      include.push({
+        model: Categoria,
+        as: 'Categoria',
+        required: false,
+        where: {
+          nombre: { [Op.like]: `%${buscar}%` },
+        },
+      });
+    
+      where[Op.or] = [
+        { nombre: { [Op.like]: `%${buscar}%` } },
+        { sku: { [Op.like]: `%${buscar}%` } },
+      ];
+    } else {
+      include.push({
+        model: Categoria,
+        as: 'Categoria',
+        required: false,
+      });
+      if (listaPrecioId) {
+        include.push({
+          model: ListaPrecioProducto,
+          as: 'listasPrecio',
+          required: true,
+          where: { listaPrecioId },
+        });
+      }
+    }
+
+    if (categoriaId) {
+      where.categoriaId = categoriaId;
+    } else {
+      where.categoriaId = { [Op.notIn]: [11, 12] };
+    }
+
+    const { count, rows } = await Producto.findAndCountAll({
+      where,
+      include,
+      offset,
+      limit: Number(limit),
+      order: [[orden, direccion]],
+    });
+
+    const totalPaginas = Math.ceil(count / limit);
+
+    reson({
+      data: rows,
+      pagina: Number(page),
+      totalPaginas,
+      totalItems: count,
+      hasNextPage: Number(page) < totalPaginas,
+      hasPrevPage: Number(page) > 1,
+    });
+  } catch (error) {
+    console.error('❌ Error al obtener productos:', error);
+    next(error);
+  }
+};
+
+export const obtenerProductoPorId = async (req, res, next) => {
+  try {
+    const producto = await Producto.findByPk(req.params.id, {
+      include: [
+        {
+          model: Categoria,
+          as: 'Categoria',
+          attributes: ['id', 'nombre'],
+        },
+        {
+          model: ImagenProducto,
+          as: 'Imagenes',
+          attributes: ['id', 'url', 'orden'],
+          required: false,
+        },
+      ],
+      order: [[{ model: ImagenProducto, as: 'Imagenes' }, 'orden', 'ASC']],
+    });
+
+    if (!producto) {
+      return res.status(404)on({ mensaje: 'Producto no encontrado' });
+    }
+
+    return reson(producto);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const crearProducto = async (req, res, next) => {
+  try {
+    const producto = await Producto.create(req.body);
+    cache.flushAll();
+    res.status(201)on(producto);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const crearProductoConImagenes = async (req, res, next) => {
+  try {
+    const {
+      sku,
+      nombre,
+      descripcion,
+      activo,
+      precioUnitario,
+      precioPorBulto,
+      unidadPorBulto,
+      categoriaId,
+    } = req.body;
+
+    const producto = await Producto.create({
+      sku,
+      nombre,
+      descripcion,
+      activo: activo === 'true',
+      precioUnitario,
+      precioPorBulto,
+      unidadPorBulto,
+      categoriaId,
+    });
+
+    if (req.files && req.files.length > 0) {
+      const imagenes = req.files.map((file, index) => ({
+        url: `/uploads/productos/${file.filename}`,
+        productoId: producto.id,
+        orden: index,
+      }));
+      await ImagenProducto.bulkCreate(imagenes);
+    }
+    
+    await crearAuditoria({
+      tabla: 'productos',
+      accion: 'crea producto',
+      registroId: producto.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se creó el prodcuto ${producto.nombre}`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+    
+    
+    cache.flushAll();
+    reson({ producto });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarProducto = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const producto = await Producto.findByPk(id);
+    if (!producto) return res.status(404)on({ message: 'Producto no encontrado' });
+
+    await producto.update(req.body);
+    cache.flushAll();
+    reson(producto);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarProductoConImagenes = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+
+    const {
+      sku,
+      nombre,
+      descripcion,
+      activo,
+      precioUnitario,
+      precioPorBulto,
+      unidadPorBulto,
+      categoriaId,
+    } = req.body;
+
+    const producto = await Producto.findByPk(id);
+    if (!producto) return res.status(404)on({ error: 'Producto no encontrado' });
+    const datosAntes = { ...producto.get() };
+    await producto.update({
+      sku,
+      nombre,
+      descripcion,
+      activo: activo === 'true',
+      precioUnitario,
+      precioPorBulto,
+      unidadPorBulto,
+      categoriaId,
+    });
+
+    if (req.files?.length) {
+      const imagenes = req.files.map((file, index) => ({
+        url: `/uploads/productos/${file.filename}`,
+        productoId: producto.id,
+        orden: index,
+      }));
+      await ImagenProducto.bulkCreate(imagenes);
+    }
+
+    await crearAuditoria({
+      tabla: 'productos',
+      accion: 'actualiza producto',
+      registroId: producto.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se actualizó el producto ${producto.nombre}`,
+      datosAntes: datosAntes,
+      datosDespues: req.body,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    cache.flushAll();
+    reson({ producto });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarProducto = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const producto = await Producto.findByPk(id);
+    if (!producto) return res.status(404)on({ message: 'Producto no encontrado' });
+
+    await producto.destroy();
+    await crearAuditoria('productos', 'eliminar', id, req.usuario?.id || null);
+    cache.flushAll();
+    reson({ message: 'Producto eliminado correctamente' });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const importarProductosDesdeExcel = async (req, res, next) => {
+  try {
+    if (!req.file) {
+      return res.status(400)on({ error: 'No se envió archivo' });
+    }
+
+    const filas = leerExcelProductos(req.file.path);
+    const productosCreados = [];
+
+    for (const fila of filas) {
+      const {
+        sku,
+        nombre,
+        descripcion,
+        activo,
+        precioUnitario,
+        precioPorBulto,
+        unidadPorBulto,
+        categoria,
+      } = fila;
+
+      if (!sku || isNaN(precioUnitario)) continue;
+
+      const yaExiste = await Producto.findOne({ where: { sku } });
+      if (yaExiste) continue;
+
+      let categoriaExistente = await Categoria.findOne({
+        where: { nombre: categoria },
+        paranoid: false,
+      });
+
+      if (categoriaExistente?.deletedAt) {
+        await categoriaExistente.restore();
+      }
+
+      if (!categoriaExistente) {
+        categoriaExistente = await Categoria.create({
+          nombre: categoria,
+          estado: true,
+        });
+      }
+
+      const producto = await Producto.create({
+        sku,
+        nombre,
+        descripcion,
+        activo: activo === 'Sí',
+        precioUnitario,
+        precioPorBulto,
+        unidadPorBulto,
+        categoriaId: categoriaExistente.id,
+      });
+
+      productosCreados.push(producto);
+    }
+    await crearAuditoria('productos', 'importar', null, req.usuario?.id || null);
+    cache.flushAll();
+    reson({
+      mensaje: `${productosCreados.length} productos importados correctamente`,
+      productos: productosCreados,
+    });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarOrdenImagenes = async (req, res, next) => {
+  try {
+    const { imagenes } = req.body;
+
+    for (const { id, orden } of imagenes) {
+      await ImagenProducto.update({ orden }, { where: { id } });
+    }
+    await crearAuditoria('productos', 'actualizar orden imagenes', null, req.usuario?.id || null);
+    reson({ mensaje: 'Orden actualizado correctamente' });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarImagenProducto = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const imagen = await ImagenProducto.findByPk(id);
+    if (!imagen) return res.status(404)on({ message: 'Imagen no encontrada' });
+
+    await imagen.destroy();
+
+    await crearAuditoria({
+      tabla: 'productos',
+      accion: 'eliminar imagen',
+      registroId: imagen.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se creó el usuario ${imagen.url}`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+    
+
+    reson({ message: 'Imagen eliminada correctamente' });
+  } catch (error) {
+    console.error('❌ Error al eliminar imagen del producto:', error);
+    next(error);
+  }
+};
+
+export const obtenerProductosRelacionadosPorTexto = async (texto = '', limite = 5) => {
+  const palabrasClave = texto
+    .toLowerCase()
+    .split(/\s+/)
+    .filter(p => p.length > 2 && !['tienen', 'hola', 'como', 'estas', 'quiero'].includes(p));
+
+  const whereProducto = {
+    activo: true,
+    precioUnitario: { [Op.gt]: 0 },
+    [Op.or]: palabrasClave.map(palabra => ({
+      [Op.or]: [
+        { nombre: { [Op.like]: `%${palabra}%` } },
+        { descripcion: { [Op.like]: `%${palabra}%` } },
+        { sku: { [Op.like]: `%${palabra}%` } },
+      ],
+    })),
+  };
+
+  const include = [
+    {
+      model: ImagenProducto,
+      as: 'Imagenes',
+      required: false,
+      attributes: ['id', 'url', 'orden'],
+      separate: true,
+      order: [['orden', 'ASC']],
+    },
+    {
+      model: Categoria,
+      as: 'Categoria',
+      required: false,
+      attributes: ['id', 'nombre'],
+      where: {
+        [Op.or]: palabrasClave.map(p => ({
+          nombre: { [Op.like]: `%${p}%` },
+        })),
+      },
+    },
+  ];
+
+  const productos = await Producto.findAll({
+    where: whereProducto,
+    include,
+    limit: Number(limite),
+    order: [['precioUnitario', 'ASC']],
+    distinct: true,
+  });
+
+  return productos;
+};
+
diff --git a/backend-nest/src/producto/producto.model.ts b/backend-nest/src/producto/producto.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..af4b6085d5fce684dc9a6cc2c04115316750ed45
--- /dev/null
+++ b/backend-nest/src/producto/producto.model.ts
@@ -0,0 +1,92 @@
+export default (sequelize, DataTypes) => {
+  const Producto = sequelize.define('Producto', {
+    nombre: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    sku: {
+      type: DataTypes.STRING,
+      allowNull: false,
+      unique: true,
+    },
+    descripcion: {
+      type: DataTypes.TEXT,
+      allowNull: true,
+    },
+    activo: {
+      type: DataTypes.BOOLEAN,
+      defaultValue: true,
+    },
+    precioUnitario: {
+      type: DataTypes.DECIMAL(10, 2),
+      allowNull: false,
+    },
+    precioPorBulto: {
+      type: DataTypes.DECIMAL(10, 2),
+      allowNull: true,
+    },
+    unidadPorBulto: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+    },
+    stock: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+      defaultValue: 0,
+    },
+    marcaId: {
+      type: DataTypes.INTEGER,
+      allowNull: true,
+      references: {
+        model: 'Marcas',
+        key: 'id',
+      },
+    },
+    categoriaId: {
+      type: DataTypes.INTEGER,
+      allowNull: false,
+      references: {
+        model: 'Categorias',
+        key: 'id',
+      },
+    },
+    costoMP: {
+      type: DataTypes.DECIMAL(10, 2),
+      allowNull: true,
+      defaultValue: 0,
+    },
+    costoDux: {
+      type: DataTypes.DECIMAL(10, 2),
+      allowNull: true,
+      defaultValue: 0,
+    },
+  }, {
+    tableName: 'Productos',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  Producto.associate = (models) => {
+    Producto.belongsTo(models.Categoria, {
+      foreignKey: 'categoriaId',
+      as: 'Categoria',
+    });
+
+    Producto.belongsTo(models.Marca, {
+      foreignKey: 'marcaId',
+      as: 'Marca',
+    });
+
+    Producto.hasMany(models.ImagenProducto, {
+      foreignKey: 'productoId',
+      as: 'Imagenes',
+    });
+
+    Producto.hasMany(models.ListaPrecioProducto, {
+      foreignKey: 'productoId',
+      as: 'listasPrecio',
+    });
+  };
+
+  return Producto;
+};
diff --git a/backend-nest/src/provincia/provincia.model.ts b/backend-nest/src/provincia/provincia.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..3f8612eef2e02ff9c917ceac12761757fc46759c
--- /dev/null
+++ b/backend-nest/src/provincia/provincia.model.ts
@@ -0,0 +1,21 @@
+export default (sequelize, DataTypes) => {
+  const Provincia = sequelize.define('Provincia', {
+    nombre: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+  }, {
+    sequelize,
+    modelName: 'Provincia',
+    tableName: 'Provincias',
+    timestamps: false,
+    paranoid: false,
+  });
+
+  Provincia.associate = (models) => {
+    Provincia.hasMany(models.Localidad, { foreignKey: 'provinciaId' });
+    Provincia.hasMany(models.Cliente, { foreignKey: 'provinciaId' });
+  };
+
+  return Provincia;
+};
diff --git a/backend-nest/src/public/clientePublic.controller.ts b/backend-nest/src/public/clientePublic.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..6c4ff585b56a6b56b2ea8fc91d2ea583edac37d7
--- /dev/null
+++ b/backend-nest/src/public/clientePublic.controller.ts
@@ -0,0 +1,67 @@
+import { Cliente, Provincia, Localidad, Usuario, LogCliente, IpCliente } from '@/models';
+import { getClientIp } from '@/utils/getClientIp';
+
+export const registrarLogPublico = async (req, res, next) => {
+  try {
+    const ip = getClientIp(req);
+    const {
+      categoriaId = null,
+      busqueda = null,
+      tiempoEnPantalla = null,
+      ubicacion = null,
+      sesion = null,
+      referer = null,
+      fuente = null,
+    } = req.body;
+
+    let ipCliente = await IpCliente.findOne({ where: { ip } });
+    if (!ipCliente) ipCliente = await IpCliente.create({ ip });
+
+    if (!busqueda && !categoriaId && !ubicacion) {
+      return res.status(400)on({ message: 'Faltan datos relevantes para registrar log' });
+    }
+
+    const log = await LogCliente.create({
+      ipClienteId: ipCliente.id,
+      categoriaId,
+      busqueda,
+      tiempoEnPantalla,
+      ubicacion,
+      sesion,
+      referer,
+      fuente,
+    });
+
+    res.status(201)on({ message: 'Log registrado', log });
+  } catch (error) {
+    console.error('❌ Error al registrar log público:', error);
+    next(error);
+  }
+};
+
+export const obtenerClientePorIp = async (req, res, next) => {
+  try {
+    const ip = getClientIp(req);
+    const registro = await IpCliente.findOne({ where: { ip } });
+    if (registro?.clienteId) return reson({ clienteId: registro.clienteId });
+    res.status(200)on({});
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const obtenerClientePorId = async (req, res, next) => {
+  try {
+    const cliente = await Cliente.findByPk(req.params.id, {
+      include: [
+        { model: Provincia, as: 'provincia' },
+        { model: Localidad, as: 'localidad' },
+        { model: Usuario, as: 'vendedor' },
+      ],
+    });
+    if (!cliente) return res.status(404)on({ message: 'Cliente no encontrado' });
+    reson(cliente);
+  } catch (error) {
+    next(error);
+  }
+};
diff --git a/backend-nest/src/public/paginaPublic.controller.ts b/backend-nest/src/public/paginaPublic.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..4fd531e2f454bee494fdf9762688a10c2f3c37d9
--- /dev/null
+++ b/backend-nest/src/public/paginaPublic.controller.ts
@@ -0,0 +1,47 @@
+import { Op } from 'sequelize';
+import { Pagina, Banner } from '@/models';
+import cache from '@/utils/cache';
+
+export const obtenerPaginaPublica = async (req, res, next) => {
+  try {
+    const cacheKey = 'pagina';
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    let pagina = await Pagina.findOne({ include: [{ model: Banner, as: 'Banners' }] });
+    if (!pagina) pagina = await Pagina.create({ logo: '' });
+
+    cache.set(cacheKey, pagina);
+    reson(pagina);
+  } catch (error) {
+    console.error('❌ Error en obtenerPaginaPublica:', error);
+    next(error);
+  }
+};
+
+export const listarBanners = async (req, res, next) => {
+  try {
+    const now = new Date();
+
+    const banners = await Banner.findAll({
+      where: {
+        [Op.or]: [
+          {
+            fechaInicio: { [Op.lte]: now },
+            fechaFin: { [Op.gte]: now },
+          },
+          {
+            fechaInicio: null,
+            fechaFin: null,
+          },
+        ],
+      },
+      order: [['orden', 'ASC']],
+    });
+
+    reson(banners);
+  } catch (error) {
+    console.error('❌ Error en listarBanners:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/public/pedidoPublic.controller.ts b/backend-nest/src/public/pedidoPublic.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..9d3fc638aed3fa3cb4ab9a39507fca9d2b5135b3
--- /dev/null
+++ b/backend-nest/src/public/pedidoPublic.controller.ts
@@ -0,0 +1,371 @@
+import {
+  Cliente,
+  Pedido,
+  DetallePedido,
+  Producto,
+  ImagenProducto,
+  Usuario,
+  EstadoPedido,
+  IpCliente,
+  IpClienteCliente,
+} from '@/models';
+
+import { Op } from 'sequelize';
+import { getClientIp } from '@/utils/getClientIp';
+import { enviarEmailEstadoEditando, enviarEmailReversionEditando, enviarEmailPedido, enviarEmailCancelacion } from '@/utils/notificaciones/email';
+import { enviarWhatsappEstadoEditando, enviarWhatsappReversionEditando, enviarWhatsappPedido, enviarWhatsappCancelacion } from 
'@/utils/notificaciones/whatsapp';
+import { verificarProductosDelCarrito } from '@/utils/validarPedido';
+import { vincularIpConCliente } from '@/controllers/ipCliente.controller';
+import { crearClienteConGeocodificacion, actualizarClienteExistenteConGeocodificacion } from '@/helpers/clientes';
+import { ESTADOS_PEDIDO } from '@/constants/estadosPedidos';
+
+export const crearOEditarPedido = async (req, res, next) => {
+  try {
+    const { cliente, carrito, usuarioId = null, pedidoId = null } = req.body;
+
+    if (!cliente || !carrito?.length) {
+      return res.status(400)on({ message: 'Faltan datos del cliente o carrito vacío' });
+    }
+
+    let clienteFinal;
+    const clienteExistente = await Cliente.findOne({ where: { cuit_cuil: cliente.cuit_cuil }, paranoid: false });
+
+    if (clienteExistente) {
+      clienteFinal = await actualizarClienteExistenteConGeocodificacion(clienteExistente, cliente, usuarioId);
+    } else {
+      clienteFinal = await crearClienteConGeocodificacion(cliente, usuarioId);
+    }
+
+    const { errores, carritoActualizado } = await verificarProductosDelCarrito(carrito);
+    if (errores.length > 0) {
+      return res.status(400)on({ mensaje: 'Algunos productos fueron modificados.', errores, carritoActualizado });
+    }
+
+    if (!pedidoId) {
+      const otroEditando = await Pedido.findOne({
+        where: {
+          clienteId: clienteFinal.id,
+          estadoEdicion: true,
+        }
+      });
+      if (otroEditando) {
+        return res.status(409)on({ message: 'Ya hay un pedido en modo edición. Confirmalo o cancelalo.' });
+      }
+    }
+
+    let pedido;
+    if (pedidoId) {
+      pedido = await Pedido.findByPk(pedidoId);
+      if (!pedido) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+      await pedido.update({ estadoPedidoId: ESTADOS_PEDIDO.PENDIENTE, estadoEdicion: false });
+
+      await Usuario.findAll({
+        where: { rolUsuarioId: { [Op.in]: [1, 2] } }, // SUPREMO, ADMINISTRADOR
+      }).then(admins =>
+        Promise.all(admins.map(admin =>
+          enviarEmailPedido({
+            cliente: clienteFinal,
+            pedido,
+            carrito,
+            vendedor: admin,
+          })
+        ))
+      );
+
+      await DetallePedido.destroy({ where: { pedidoId: pedido.id } });
+    } else {
+      pedido = await Pedido.create({
+        clienteId: clienteFinal.id,
+        usuarioId,
+        total: 0,
+        estadoPedidoId: ESTADOS_PEDIDO.PENDIENTE,
+        estadoEdicion: false,
+      });
+    }
+
+    let total = 0;
+    for (const item of carrito) {
+      const productoDb = await Producto.findByPk(item.id);
+      if (!productoDb) continue;
+
+      const pxb = productoDb.precioUnitario * productoDb.unidadPorBulto;
+      const subtotal = item.cantidad * pxb;
+
+      await DetallePedido.create({
+        pedidoId: pedido.id,
+        clienteId: clienteFinal.id,
+        productoId: item.id,
+        cantidad: item.cantidad,
+        unidadPorBulto: productoDb.unidadPorBulto,
+        precioUnitario: productoDb.precioUnitario,
+        precioPorBulto: pxb,
+        subtotal,
+      });
+
+      total += subtotal;
+    }
+
+    await pedido.update({ total });
+
+    const ip = getClientIp(req);
+    let ipCliente = await IpCliente.findOne({ where: { ip } });
+    if (!ipCliente) ipCliente = await IpCliente.create({ ip });
+    await vincularIpConCliente(ipCliente.id, clienteFinal.id);
+
+    const vendedor = usuarioId ? await Usuario.findByPk(usuarioId) : null;
+
+    await enviarEmailPedido({ cliente: clienteFinal, pedido, carrito, vendedor });
+    await enviarWhatsappPedido({ cliente: clienteFinal, pedido, carrito, vendedor });
+
+    res.status(201)on({
+      message: pedidoId ? 'Pedido editado correctamente' : 'Pedido en edición',
+      pedidoId: pedido.id,
+      clienteId: clienteFinal.id,
+    });
+  } catch (error) {
+    console.error('❌ Error en crearOEditarPedido:', error);
+    next(error);
+  }
+};
+
+export const obtenerPedidosClientePorId = async (req, res, next) => {
+  try {
+    const ip = getClientIp(req);
+
+    const ipCliente = await IpCliente.findOne({ where: { ip } });
+    if (!ipCliente) return res.status(200)on([]);
+
+    const relaciones = await IpClienteCliente.findAll({ where: { ipClienteId: ipCliente.id } });
+    const clienteIds = relaciones.map((r) => r.clienteId).filter(Boolean);
+
+    if (clienteIds.length === 0) return res.status(200)on([]);
+
+    const pedidos = await Pedido.findAll({
+      where: { clienteId: { [Op.in]: clienteIds } },
+      include: [
+        { model: DetallePedido, as: 'detalles', include: [{ model: Producto, as: 'producto', include: [{ model: ImagenProducto, as: 'Imagenes' }] }] 
},
+        { model: Cliente, as: 'cliente' },
+        { model: Usuario, as: 'usuario' },
+        { model: EstadoPedido, as: 'estadoPedido' },
+      ],
+      order: [['createdAt', 'DESC']],
+    });
+
+    reson(pedidos);
+  } catch (error) {
+    console.error('❌ Error en obtenerPedidosClientePorId:', error);
+    next(error);
+  }
+};
+
+export const obtenerPedidoPorId = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    if (isNaN(id)) return res.status(400)on({ message: 'ID inválido' });
+
+    const pedido = await Pedido.findByPk(id, {
+      include: [
+        { model: DetallePedido, as: 'detalles', include: [{ model: Producto, as: 'producto', include: [{ model: ImagenProducto, as: 'Imagenes' }] }] 
},
+        { model: Cliente, as: 'cliente' },
+        { model: Usuario, as: 'usuario' },
+        { model: EstadoPedido, as: 'estadoPedido' },
+      ],
+    });
+
+    if (!pedido) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+    reson(pedido);
+  } catch (error) {
+    console.error('❌ Error en obtenerPedidoPorId:', error);
+    next(error);
+  }
+};
+
+export const marcarComoEditando = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+
+    const pedido = await Pedido.findByPk(id);
+    if (!pedido) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+    await Pedido.update(
+      { estadoEdicion: false },
+      {
+        where: {
+          clienteId: pedido.clienteId,
+          estadoEdicion: true,
+          id: { [Op.ne]: pedido.id },
+        },
+      }
+    );
+
+    await pedido.update({ estadoEdicion: true });
+
+    await enviarEmailEstadoEditando({ pedido });
+    await enviarWhatsappEstadoEditando({ pedido });
+
+    reson({ message: 'Pedido en edición', estadoEdicion: true });
+  } catch (error) {
+    console.error('❌ Error marcarComoEditando:', error);
+    next(error);
+  }
+};
+
+export const revertirEditando = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+
+    const pedido = await Pedido.findByPk(id);
+    if (!pedido) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+    await pedido.update({ estadoEdicion: false });
+
+    await enviarEmailReversionEditando({ pedido });
+    await enviarWhatsappReversionEditando({ pedido });
+
+    reson({ message: 'Edición revertida', estadoEdicion: false });
+  } catch (error) {
+    console.error('❌ Error revertirEditando:', error);
+    next(error);
+  }
+};
+
+export const cancelarPedidoDesdeCliente = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+
+    const pedido = await Pedido.findByPk(id);
+    if (!pedido) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+    await pedido.update({
+      estadoPedidoId: ESTADOS_PEDIDO.CANCELADO,
+      estadoEdicion: false,
+    });
+
+    const cliente = await pedido.getCliente();
+    const vendedor = await pedido.getUsuario();
+
+    await enviarEmailCancelacion({ cliente, pedido, vendedor });
+    await enviarWhatsappCancelacion({ cliente, pedido, vendedor });
+
+    reson({ message: 'Pedido cancelado correctamente' });
+  } catch (error) {
+    console.error('❌ Error cancelarPedidoDesdeCliente:', error);
+    next(error);
+  }
+};
+
+export const validarCarritoSolo = async (req, res, next) => {
+  try {
+    const { carrito } = req.body;
+
+    if (!Array.isArray(carrito) || carrito.length === 0) {
+      return res.status(400)on({ message: 'Carrito vacío' });
+    }
+
+    const detalles = [];
+    let total = 0;
+
+    for (const item of carrito) {
+      const productoDb = await Producto.findByPk(item.id);
+      if (!productoDb) continue;
+
+      const precioUnitario = productoDb.precioUnitario;
+      const precioPorBulto =  precioUnitario * productoDb.unidadPorBulto;
+      const subtotal = item.cantidad * precioPorBulto;
+
+      detalles.push({
+        productoId: item.id,
+        nombre: productoDb.nombre,
+        cantidad: item.cantidad,
+        unidadPorBulto: productoDb.unidadPorBulto,
+        precioUnitario,
+        precioPorBulto,
+        subtotal,
+      });
+
+      total += subtotal;
+    }
+
+    reson({ detalles, total });
+  } catch (error) {
+    console.error('❌ Error al validar carrito:', error);
+    next(error);
+  }
+};
+
+export const duplicarPedido = async (req, res, next) => {
+  try {
+    const { pedidoId } = req.body;
+
+    if (!pedidoId) return res.status(400)on({ message: 'Pedido ID es obligatorio' });
+
+    const pedidoOriginal = await Pedido.findByPk(pedidoId, {
+      include: [
+        { model: DetallePedido, as: 'detalles', include: [{ model: Producto, as: 'producto' }] },
+        { model: Cliente, as: 'cliente' },
+        { model: Usuario, as: 'usuario' },
+      ],
+    });
+
+    if (!pedidoOriginal) return res.status(404)on({ message: 'Pedido no encontrado' });
+
+    const nuevoPedido = await Pedido.create({
+      clienteId: pedidoOriginal.clienteId,
+      usuarioId: pedidoOriginal.usuarioId,
+      total: 0,
+      estadoPedidoId: ESTADOS_PEDIDO.PENDIENTE,
+      estadoEdicion: false,
+    });
+
+    let total = 0;
+    for (const item of pedidoOriginal.detalles) {
+      const productoDb = await Producto.findByPk(item.productoId);
+      if (!productoDb) continue;
+
+      const precioUnitario = productoDb.precioUnitario;
+      const precioPorBulto =  precioUnitario * productoDb.unidadPorBulto;
+      const subtotal = item.cantidad * precioPorBulto;
+
+      await DetallePedido.create({
+        pedidoId: nuevoPedido.id,
+        clienteId: pedidoOriginal.clienteId,
+        productoId: item.productoId,
+        cantidad: item.cantidad,
+        unidadPorBulto: productoDb.unidadPorBulto,
+        precioUnitario,
+        precioPorBulto: precioPorBulto,
+        subtotal,
+      });
+
+      total += subtotal;
+    }
+
+    await nuevoPedido.update({ total });
+
+    const vendedor = await Usuario.findByPk(nuevoPedido.usuarioId);
+    await enviarEmailPedido({
+      cliente: pedidoOriginal.cliente,
+      pedido: nuevoPedido,
+      carrito: pedidoOriginal.detalles,
+      vendedor,
+    });
+
+    await enviarWhatsappPedido({
+      cliente: pedidoOriginal.cliente,
+      pedido: nuevoPedido,
+      carrito: pedidoOriginal.detalles,
+      vendedor,
+    });
+
+    res.status(201)on({
+      message: 'Pedido duplicado correctamente',
+      pedidoId: nuevoPedido.id,
+      clienteId: pedidoOriginal.clienteId,
+    });
+  } catch (error) {
+    console.error('❌ Error en duplicarPedido:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/public/productoPublic.controller.ts b/backend-nest/src/public/productoPublic.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..8ed1056a893faeae4150f4e3ad09bc404f68cc70
--- /dev/null
+++ b/backend-nest/src/public/productoPublic.controller.ts
@@ -0,0 +1,150 @@
+import { Producto, Categoria, ImagenProducto } from '@/models';
+import { estadoSync } from '@/state/estadoSync';
+import { Op, Sequelize } from 'sequelize';
+import cache from '@/utils/cache';
+
+export const listarProductosPublicos = async (req, res, next) => {
+  try {
+    const {
+      page = 1,
+      limit = 12,
+      orden = 'createdAt',
+      direccion = 'DESC',
+      buscar = '',
+      categoria,
+    } = req.query;
+
+    const ultimaActualizacion = estadoSync.ultimaActualizacionProductos || 'v1';
+    const cacheKey = `productos_${ultimaActualizacion}_${page}_${limit}_${orden}_${direccion}_${buscar}_${categoria}`;
+
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    const offset = (page - 1) * limit;
+    const direccionValidada = ['ASC', 'DESC'].includes(direccion.toUpperCase()) ? direccion.toUpperCase() : 'DESC';
+
+    const where = { activo: true };
+    if (buscar) where.nombre = { [Op.like]: `%${buscar}%` };
+
+    const include = [
+      {
+        model: Categoria,
+        as: 'Categoria',
+        attributes: ['id', 'nombre'],
+        ...(categoria && categoria !== 'Todas'
+          ? {
+            where: {
+              estado: true,
+              [Op.or]: [
+                { nombre: categoria },
+                { nombreWeb: categoria }
+              ]
+            }
+          }
+          : {}),
+      },
+      {
+        model: ImagenProducto,
+        as: 'Imagenes',
+        attributes: ['id', 'url', 'orden'],
+        required: true,
+      },
+    ];
+
+
+    const { count, rows } = await Producto.findAndCountAll({
+      where,
+      include,
+      limit: Number(limit),
+      offset,
+      order: [
+        [orden, direccionValidada],
+        [{ model: ImagenProducto, as: 'Imagenes' }, 'orden', 'ASC'],
+      ],
+      distinct: true,
+    });
+
+    const response = {
+      data: rows,
+      pagina: Number(page),
+      totalPaginas: Math.ceil(count / limit),
+      totalItems: count,
+      hasNextPage: Number(page) < Math.ceil(count / limit),
+      hasPrevPage: Number(page) > 1,
+    };
+
+    cache.set(cacheKey, response);
+    reson(response);
+  } catch (error) {
+    console.error("❌ Error en listarProductosPublicos:", error);
+    next(error);
+  }
+};
+
+export const obtenerProductoPorId = async (req, res, next) => {
+  try {
+    const producto = await Producto.findByPk(req.params.id, {
+      include: [
+        {
+          model: Categoria,
+          as: 'Categoria',
+          attributes: ['id', 'nombre'],
+        },
+        {
+          model: ImagenProducto,
+          as: 'Imagenes',
+          attributes: ['id', 'url', 'orden'],
+        },
+      ],
+      order: [[{ model: ImagenProducto, as: 'Imagenes' }, 'orden', 'ASC']],
+    });
+
+    if (!producto) {
+      return res.status(404)on({ mensaje: 'Producto no encontrado' });
+    }
+
+    return reson(producto);
+  } catch (error) {
+    console.error('❌ Error en obtenerProductoPorId:', error);
+    next(error);
+  }
+};
+
+export const listarCategorias = async (req, res, next) => {
+  try {
+    const version = estadoSync.ultimaActualizacionProductos || 'v1';
+    const cacheKey = `categoriasPublicas_${version}`;
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    const categorias = await Categoria.findAll({
+      attributes: [
+        'id',
+        'nombre',
+        'nombreWeb',
+        [Sequelize.fn('COUNT', Sequelize.col('Productos.id')), 'cantidadProductos']
+      ],
+      where: { estado: true },
+      include: [
+        {
+          model: Producto,
+          as: 'Productos',
+          required: true,
+          attributes: [],
+          where: { activo: true },
+          include: [{ model: ImagenProducto, as: 'Imagenes', required: true, attributes: [] }],
+        },
+      ],
+      group: ['Categoria.id'],
+      order: [['orden', 'ASC']],
+      subQuery: false,
+      distinct: true,
+    });
+
+    cache.set(cacheKey, categorias);
+    reson(categorias);
+  } catch (error) {
+    console.error("❌ Error en listarCategorias:", error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/public/public.controller.ts b/backend-nest/src/public/public.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..4abfbd72365d0a4c163464958e5233b635734c25
--- /dev/null
+++ b/backend-nest/src/public/public.controller.ts
@@ -0,0 +1,73 @@
+import {
+  Banner,
+  Usuario,
+  Pagina,
+} from '@/models';
+import { Op } from 'sequelize';
+import cache from '@/utils/cache';
+
+// PÁGINA
+export const obtenerPaginaPublica = async (req, res, next) => {
+  try {
+    const cacheKey = 'pagina';
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    let pagina = await Pagina.findOne({ include: [{ model: Banner, as: 'Banners' }] });
+    if (!pagina) pagina = await Pagina.create({ logo: '' });
+
+    cache.set(cacheKey, pagina);
+    reson(pagina);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const listarBanners = async (req, res, next) => {
+  try {
+    const now = new Date();
+
+    const banners = await Banner.findAll({
+      where: {
+        [Op.or]: [
+          {
+            fechaInicio: { [Op.lte]: now },
+            fechaFin: { [Op.gte]: now },
+          },
+          {
+            fechaInicio: null,
+            fechaFin: null,
+          },
+        ],
+      },
+      order: [['orden', 'ASC']],
+    });
+
+    reson(banners);
+  } catch (error) {
+    next(error);
+  }
+};
+
+// VENDEDOR
+export const buscarVendedorPorLink = async (req, res, next) => {
+  try {
+    const { link } = req.params;
+
+    const vendedor = await Usuario.findOne({
+      where: {
+        link,
+        rolUsuarioId: ROLES_USUARIO.VENDEDOR,
+      },
+      attributes: ['id', 'nombre', 'email', 'telefono', 'link'],
+    });
+
+    if (!vendedor) {
+      return res.status(404)on({ error: 'Vendedor no encontrado' });
+    }
+
+    reson(vendedor);
+  } catch (error) {
+    next(error);
+  }
+};
diff --git a/backend-nest/src/public/ubicacion.controller.ts b/backend-nest/src/public/ubicacion.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..435c5f37b6db8c49f37b90e6fd5e5016277b2cc1
--- /dev/null
+++ b/backend-nest/src/public/ubicacion.controller.ts
@@ -0,0 +1,87 @@
+import { Provincia, Localidad } from '@/models';
+import { Op } from 'sequelize';
+import cache from '@/utils/cache';
+
+export const listarProvincias = async (req, res, next) => {
+  try {
+    const cacheKey = 'provincias';
+    const cached = cache.get(cacheKey);
+    if (cached) return reson(cached);
+
+    const provincias = await Provincia.findAll({
+      attributes: ['id', 'nombre'],
+      order: [['nombre', 'ASC']],
+    });
+
+    cache.set(cacheKey, provincias);
+    reson(provincias);
+  } catch (error) {
+    console.error("❌ Error en listarProvincias:", error);
+    next(error);
+  }
+};
+
+export const listarLocalidadesPorProvincia = async (req, res, next) => {
+  try {
+    const { provinciaId } = req.params;
+    if (!provinciaId || isNaN(provinciaId)) {
+      return res.status(400)on({ error: 'Provincia inválida' });
+    }
+
+    const localidades = await Localidad.findAll({
+      where: { provinciaId },
+      attributes: ['id', 'nombre'],
+      order: [['nombre', 'ASC']],
+    });
+    reson(localidades);
+  } catch (error) {
+    console.error("❌ Error en listarLocalidadesPorProvincia:", error);
+    next(error);
+  }
+};
+
+export const listarLocalidadesPorProvinciaInput = async (req, res, next) => {
+  try {
+    const { q, provinciaId } = req.query;
+
+    if (!provinciaId || isNaN(provinciaId) || !q) {
+      return res.status(400)on({ error: 'Faltan parámetros provinciaId o q' });
+    }
+
+    const localidades = await Localidad.findAll({
+      where: {
+        nombre: { [Op.like]: `%${q}%` },
+        provinciaId: Number(provinciaId),
+      },
+      attributes: ['id', 'nombre'],
+      order: [['nombre', 'ASC']],
+    });
+
+    reson(localidades);
+  } catch (error) {
+    console.error("❌ Error en listarLocalidadesPorProvinciaInput:", error);
+    next(error);
+  }
+};
+
+export const listarUbicaciones = async (req, res, next) => {
+  try {
+    const localidades = await Localidad.findAll({
+      attributes: ['id', 'nombre', 'codigoPostal', 'provinciaId'],
+      order: [['nombre', 'ASC']],
+    });
+
+    const ubicaciones = localidades.map(loc => ({
+      id: loc.id,
+      nombre: loc.nombre,
+      codigoPostal: loc.codigoPostal,
+      localidadId: loc.id,
+      provinciaId: loc.provinciaId,
+    }));
+
+    reson(ubicaciones);
+  } catch (error) {
+    console.error("❌ Error al listar ubicaciones:", error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/public/validacionWhatsapp.controller.ts b/backend-nest/src/public/validacionWhatsapp.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..bdda0710c4bedef95b2317905a46787c48e7d30a
--- /dev/null
+++ b/backend-nest/src/public/validacionWhatsapp.controller.ts
@@ -0,0 +1,36 @@
+import { enviarMensajeValidacionUsuario } from '@/helpers/enviarMensajeWhatsapp';
+
+const codigos = new Map(); // temporal, ideal usar Redis
+
+export const enviarCodigoWhatsapp = async (req, res) => {
+  const { telefono } = req.body;
+  if (!telefono) return res.status(400).json({ message: 'Teléfono requerido' });
+
+  const codigo = Math.floor(100000 + Math.random() * 900000).toString();
+  codigos.set(telefono, { codigo, creado: Date.now() });
+  const telefonoSoporte = process.env.WHATSAPP_SOPORTE ;
+
+  try {
+    await enviarMensajeValidacionUsuario(telefono, codigo, telefonoSoporte);
+    res.status(200).json({ message: 'Código enviado' });
+  } catch (err) {
+    console.error('❌ Error al enviar WhatsApp:', err);
+    res.status(500).json({ message: 'No se pudo enviar el mensaje' });
+  }
+};
+
+export const validarCodigoWhatsapp = async (req, res) => {
+  const { telefono, codigo } = req.body;
+  const registro = codigos.get(telefono);
+  if (!registro || registro.codigo !== codigo) {
+    return res.status(400).json({ message: 'Código inválido' });
+  }
+  const expirado = Date.now() - registro.creado > 10 * 60 * 1000; // 10 minutos
+  if (expirado) {
+    codigos.delete(telefono);
+    return res.status(400).json({ message: 'Código expirado' });
+  }
+
+  codigos.delete(telefono);
+  res.status(200).json({ message: 'Código verificado correctamente' });
+};
diff --git a/backend-nest/src/public/vendedorPublic.controller.ts b/backend-nest/src/public/vendedorPublic.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..e2200d23c1a2cdfe247cc8c063df6ec0b036584e
--- /dev/null
+++ b/backend-nest/src/public/vendedorPublic.controller.ts
@@ -0,0 +1,24 @@
+import { Usuario } from '@/models';
+
+export const buscarVendedorPorLink = async (req, res, next) => {
+  try {
+    const { link } = req.params;
+
+    const vendedor = await Usuario.findOne({
+      where: {
+        link,
+        rolUsuarioId: 3, // ROLES_USUARIO.VENDEDOR
+      },
+      attributes: ['id', 'nombre', 'email', 'telefono', 'link'],
+    });
+
+    if (!vendedor) {
+      return res.status(404).json({ error: 'Vendedor no encontrado' });
+    }
+
+    res.json(vendedor);
+  } catch (error) {
+    console.error('❌ Error en buscarVendedorPorLink:', error);
+    next(error);
+  }
+};
diff --git a/backend-nest/src/reporteproduccion/reporteproduccion.controller.ts b/backend-nest/src/reporteproduccion/reporteproduccion.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..5df0eb39ffe791b1d19ff03df736015887f530e0
--- /dev/null
+++ b/backend-nest/src/reporteproduccion/reporteproduccion.controller.ts
@@ -0,0 +1,122 @@
+import { ReporteProduccion, Producto, Usuario, LogAuditoria, Planta } from '@/models';
+import { Op } from "sequelize";
+import { crearAuditoria } from "@/utils/auditoria";
+
+export const obtenerReportesProduccion = async (req, res, next) => {
+  try {
+    const pagina = parseInt(req.query.page) || 1;
+    const limit = parseInt(req.query.limit) || 10;
+    const offset = (pagina - 1) * limit;
+    const orden = req.query.orden || "fecha";
+    const direccion = req.query.direccion?.toUpperCase() === "ASC" ? "ASC" : "DESC";
+    const where = {};
+
+    if (req.query.turno) {
+      where.turno = req.query.turno;
+    }
+
+    if (req.query.plantaId) {
+      where.plantaId = req.query.plantaId;
+    }
+
+    if (req.query.desde && req.query.hasta) {
+      const desde = new Date(req.query.desde + 'T00:00:00');
+      const hasta = new Date(req.query.hasta + 'T23:59:59');
+      where.fecha = {
+        [Op.between]: [new Date(desde), new Date(hasta)],
+      };
+    }
+
+    let order;
+    if (orden.includes(".")) {
+      const partes = orden.split(".");
+      order = [[...partes, direccion]];
+    } else {
+      order = [[orden, direccion]];
+    }
+
+
+    const { count, rows } = await ReporteProduccion.findAndCountAll({
+      where,
+      include: [
+        { model: Producto, as: "producto" },
+        { model: Usuario, as: "usuario", attributes: ["id", "nombre", "email"] },
+        { model: Planta, as: "planta", attributes: ["id", "nombre", "direccion"] }
+      ],
+      order,
+      limit,
+      offset,
+    });
+
+    const totalPaginas = Math.ceil(count / limit);
+
+    reson({
+      data: rows,
+      total: count,
+      pagina,
+      totalPaginas,
+    });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const crearReporteProduccion = async (req, res, next) => {
+  try {
+    const { productoId, cantidad, plantaId, turno } = req.body;
+    const usuarioId = req.usuario?.id || req.body.usuarioId;
+
+    if (!productoId || !cantidad || !usuarioId) {
+      return res.status(400)on({ mensaje: "Faltan datos obligatorios" });
+    }
+
+    const nuevo = await ReporteProduccion.create({
+      productoId,
+      cantidad,
+      usuarioId,
+      plantaId,
+      turno,
+    });
+    
+    await crearAuditoria({
+      tabla: 'reporte produccion diaria',
+      accion: 'crea reporte',
+      registroId: nuevo.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se creó el reporte de producción con ID ${nuevo.id}`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+    
+
+    reson(nuevo);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarReporteProduccion = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const usuarioId = req.usuario?.id;
+
+    if (!usuarioId) {
+      return res.status(401)on({ mensaje: "Usuario no autenticado" });
+    }
+
+    // 1. Eliminar el reporte
+    await ReporteProduccion.destroy({ where: { id } });
+
+    await crearAuditoria({
+      tabla: 'reporte produccion diaria',
+      accion: 'elimina reporte',
+      registroId: id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se eliminó el reporte de producción con ID ${id}`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    reson({ mensaje: "Reporte eliminado y registrado correctamente" });
+  } catch (error) {
+    next(error);
+  }
+};
\ No newline at end of file
diff --git a/backend-nest/src/reporteproduccion/reporteproduccion.model.ts b/backend-nest/src/reporteproduccion/reporteproduccion.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..235c890ef728351530dd72ad01e67ee697532853
--- /dev/null
+++ b/backend-nest/src/reporteproduccion/reporteproduccion.model.ts
@@ -0,0 +1,61 @@
+export default (sequelize, DataTypes) => {
+  const ReporteProduccion = sequelize.define(
+    "ReporteProduccion",
+    {
+      id: {
+        type: DataTypes.INTEGER.UNSIGNED,
+        primaryKey: true,
+        autoIncrement: true,
+      },
+      fecha: {
+        type: DataTypes.DATE,
+        allowNull: true,
+      },
+      productoId: {
+        type: DataTypes.INTEGER.UNSIGNED,
+        allowNull: false,
+      },
+      cantidad: {
+        type: DataTypes.INTEGER,
+        allowNull: false,
+      },
+      usuarioId: {
+        type: DataTypes.INTEGER,
+        allowNull: false,
+      },
+      turno: {
+        type: DataTypes.ENUM("mañana", "tarde", "noche"),
+        allowNull: false,
+        defaultValue: "mañana",
+      },
+      plantaId: {
+        type: DataTypes.INTEGER.UNSIGNED,
+        allowNull: true,
+      },
+    },
+    {
+      tableName: "ReporteProducciones",
+      timestamps: true,
+      paranoid: true,
+    }
+  );
+
+  ReporteProduccion.associate = (models) => {
+    ReporteProduccion.belongsTo(models.Producto, {
+      foreignKey: "productoId",
+      as: "producto",
+    });
+
+    ReporteProduccion.belongsTo(models.Usuario, {
+      foreignKey: "usuarioId",
+      as: "usuario",
+    });
+
+    ReporteProduccion.belongsTo(models.Planta, {
+      foreignKey: "plantaId",
+      as: "planta",
+    });
+  };
+
+  return ReporteProduccion;
+};
diff --git a/backend-nest/src/rolusuario/rolusuario.controller.ts b/backend-nest/src/rolusuario/rolusuario.controller.ts
new file mode 100644
index 0000000000000000000000000000000000000000..598284071276b0966cb6c8fe40b4684ae6dafece
--- /dev/null
+++ b/backend-nest/src/rolusuario/rolusuario.controller.ts
@@ -0,0 +1,84 @@
+import { RolUsuario, PermisosUsuario, Modulo } from '@/models';
+
+export const listarRolesUsuario = async (req, res, next) => {
+  try {
+    const roles = await RolUsuario.findAll({ order: [['id', 'ASC']] });
+    res.json(roles);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const obtenerPermisosPorRol = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const permisos = await PermisosUsuario.findAll({
+      where: { rolUsuarioId: Number(id) },
+      order: [['moduloId', 'ASC'], ['accion', 'ASC']],
+      include: [
+        {
+          model: Modulo,
+          as: 'modulo',
+          attributes: ['nombre'] // solo trae el nombre
+        }
+      ]
+    });
+    res.json(permisos);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarPermisosPorRol = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const cambios = req.body; // Array de { id, permitido }
+
+    for (const cambio of cambios) {
+      await PermisosUsuario.update(
+        { permitido: cambio.permitido },
+        { where: { id: cambio.id, rolUsuarioId: Number(id) } }
+      );
+    }
+
+    res.json({ mensaje: 'Permisos actualizados' });
+  } catch (error) {
+    next(error);
+  }
+};
+
+
+export const crearRolUsuario = async (req, res, next) => {
+  try {
+    const { nombre, descripcion } = req.body;
+    const nuevo = await RolUsuario.create({ nombre, descripcion });
+    res.status(201).json(nuevo);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarRolUsuario = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const { nombre, descripcion } = req.body;
+    const rol = await RolUsuario.findByPk(id);
+    if (!rol) return res.status(404).json({ mensaje: 'Rol no encontrado' });
+    await rol.update({ nombre, descripcion });
+    res.json(rol);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarRolUsuario = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const rol = await RolUsuario.findByPk(id);
+    if (!rol) return res.status(404).json({ mensaje: 'Rol no encontrado' });
+    await rol.destroy();
+    res.json({ mensaje: 'Rol eliminado correctamente' });
+  } catch (error) {
+    next(error);
+  }
+};
diff --git a/backend-nest/src/rolusuario/rolusuario.model.ts b/backend-nest/src/rolusuario/rolusuario.model.ts
new file mode 100644
index 0000000000000000000000000000000000000000..ed7df72e89db2f37bdc442bfa17e36531222d8e6
--- /dev/null
+++ b/backend-nest/src/rolusuario/rolusuario.model.ts
@@ -0,0 +1,31 @@
+export default (sequelize, DataTypes) => {
+    const RolUsuario = sequelize.define('RolUsuario', {
+      nombre: {
+        type: DataTypes.STRING,
+        allowNull: false,
+        unique: true,
+      },
+      descripcion: {
+        type: DataTypes.STRING,
+        allowNull: true,
+      },
+    }, {
+      tableName: 'RolesUsuarios',
+      timestamps: true,
+      paranoid: true,
+    });
+  
+    RolUsuario.associate = (models) => {
+      RolUsuario.hasMany(models.Usuario, {
+        foreignKey: 'rolUsuarioId',
+        as: 'usuarios',
+      });
+      RolUsuario.hasMany(models.PermisosUsuario, {
+        foreignKey: 'rolUsuarioId',
+        as: 'permisos'
+      });
+    };
+  
+    return RolUsuario;
+  };
+  
diff --git a/backend-nest/src/usuario/usuario.controller.ts b/backend-nest/src/usuario/usuario.controller.ts
new file mode 100755
index 0000000000000000000000000000000000000000..b6bc4f3df41213bb2b25eb85e96233ecadef6cd8
--- /dev/null
+++ b/backend-nest/src/usuario/usuario.controller.ts
@@ -0,0 +1,262 @@
+import { Usuario, RolUsuario } from '@/models';
+import bcrypt from 'bcryptjs';
+import { Op } from 'sequelize';
+import { nanoid } from 'nanoid';
+import { ROLES_USUARIOS } from '@/constants/rolesUsuarios';
+import { puedeActualizarUsuario } from '@/utils/puedeActualizarUsuario';
+import { crearAuditoria } from '@/utils/auditoria';
+
+export const crearUsuario = async (req, res, next) => {
+  try {
+    const { nombre, email, telefono, rolUsuarioId } = req.body;
+
+    // 🛡️ Validaciones extra
+    if (!nombre || !email || rolUsuarioId == null) {
+      return res.status(400)on({ message: 'Faltan campos obligatorios' });
+    }
+
+    // 🔍 Asegurar que sea número
+    const idRol = Number(rolUsuarioId);
+    console.log('💬 rolUsuarioId recibido:', rolUsuarioId, 'tipo:', typeof rolUsuarioId);
+
+    if (!Object.values(ROLES_USUARIOS).includes(idRol)) {
+      return res.status(400)on({ message: 'Rol inválido' });
+    }
+
+    // 📧 Verificar si el email ya existe
+    const existente = await Usuario.findOne({ where: { email } });
+    if (existente) {
+      return res.status(400)on({ message: 'El email ya está en uso.' });
+    }
+
+    // ☎️ Para vendedor o admin, teléfono es obligatorio
+    if ((idRol === ROLES_USUARIOS.VENDEDOR || idRol === ROLES_USUARIOS.ADMINISTRADOR) && !telefono) {
+      return res.status(400)on({ message: 'El teléfono es obligatorio para este tipo de usuario.' });
+    }
+
+    // 🔗 Si es vendedor, generar link único
+    let link = null;
+    if (idRol === ROLES_USUARIOS.VENDEDOR) {
+      link = nanoid(4).toUpperCase();
+    }
+
+    // ✅ Crear el usuario
+    const usuario = await Usuario.create({
+      nombre,
+      email,
+      telefono: telefono || null,
+      rolUsuarioId: idRol,
+      contraseña: null,
+      link,
+    });
+
+    // 🧾 Auditoría
+    await crearAuditoria({
+      tabla: 'usuarios',
+      accion: 'crea usuario',
+      registroId: usuario.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se creó el usuario ${usuario.nombre}`,
+      ip: req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null,
+    });
+
+    res.status(201)on(usuario);
+  } catch (error) {
+    console.error('❌ Error en crearUsuario:', error);
+    next(error);
+  }
+};
+
+export const obtenerUsuariosOperarios = async (req, res, next) => {
+  try {
+    const usuarios = await Usuario.findAll({
+      where: {
+        rolUsuarioId: {
+          [Op.in]: [4, 5, 6, 7] // 👈 Todos los operarios
+        }
+      },
+      order: [['nombre', 'ASC']],
+      include: [
+        {
+          model: RolUsuario,
+          as: 'rolUsuario',
+          attributes: ['nombre']
+        }
+      ]
+    });
+
+    reson(usuarios);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const obtenerUsuariosPorRol = async (req, res, next) => {
+  try {
+    const rol = req.params.rol;
+
+    const rolEncontrado = await RolUsuario.findOne({
+      where: whereSequelize(fn('LOWER', col('nombre')), rol.toLowerCase())
+    });
+
+    if (!rolEncontrado) {
+      return res.status(400)on({ mensaje: 'Rol no válido' });
+    }
+
+    const { page = 1, limit = 20, busqueda = '' } = req.query;
+    const offset = (parseInt(page) - 1) * parseInt(limit);
+
+    const where = {
+      rolUsuarioId: rolEncontrado.id,
+      [Op.or]: [
+        { nombre: { [Op.like]: `%${busqueda}%` } },
+        { email: { [Op.like]: `%${busqueda}%` } }
+      ]
+    };
+
+    const { rows: usuarios, count: total } = await Usuario.findAndCountAll({
+      where,
+      limit: parseInt(limit),
+      offset,
+      order: [['nombre', 'ASC']],
+      include: [
+        { model: RolUsuario, as: 'rolUsuario', attributes: ['nombre'] }
+      ]
+    });
+
+    reson({
+      usuarios,
+      total,
+      pagina: parseInt(page),
+      totalPaginas: Math.ceil(total / limit)
+    });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const obtenerUsuariosPorRolId = async (req, res, next) => {
+  try {
+    const rolUsuarioId = Number(req.params.id);
+    const usuarios = await Usuario.findAll({
+      where: { rolUsuarioId },
+      order: [['nombre', 'ASC']],
+    });
+    reson(usuarios);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const actualizarUsuario = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const usuario = await Usuario.findByPk(id);
+    if (!usuario) return res.status(404)on({ message: 'Usuario no encontrado' });
+    const datosAntes = usuario.toJSON();
+    
+    const puede = puedeActualizarUsuario({
+      usuarioLogueado: req.usuario,
+      usuarioObjetivo: usuario,
+      bodyUpdate: req.body,
+    });
+
+    if (!puede) {
+      return res.status(403)on({ message: 'No autorizado para actualizar este usuario.' });
+    }
+
+    const { contraseña, ...resto } = req.body;
+
+    // 🚫 No se actualiza la contraseña desde acá nunca más
+    await usuario.update(resto);
+
+    const datosDespues = usuario.toJSON();
+    const ip = req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null;
+    await crearAuditoria({
+      tabla: 'usuarios',
+      accion: 'actualiza usuario',
+      registroId: usuario.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Usuario ${usuario.nombre} actualizado.`,
+      datosAntes,
+      datosDespues,
+      ip,
+    });
+
+    reson(usuario);
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const cambiarContrasena = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const { contraseña } = req.body;
+
+    if (!contraseña) {
+      return res.status(400)on({ message: 'La contraseña es obligatoria.' });
+    }
+
+    const usuario = await Usuario.findByPk(id);
+    if (!usuario) {
+      return res.status(404)on({ message: 'Usuario no encontrado.' });
+    }
+
+    const puede = puedeActualizarUsuario({
+      usuarioLogueado: req.usuario,
+      usuarioObjetivo: usuario,
+      bodyUpdate: { contraseña },
+    });
+    if (!puede) {
+      return res.status(403)on({ message: 'No autorizado para cambiar contraseña.' });
+    }
+
+    const hash = await bcrypt.hash(contraseña, 10);
+    await usuario.update({ contraseña: hash });
+
+    const ip = req.headers['x-forwarded-for'] || req.connection.remoteAddress || '';
+
+    await crearAuditoria({
+      tabla: 'usuarios',
+      accion: 'cambia contraseña',
+      registroId: usuario.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se cambió la contraseña de ${usuario.nombre}`,
+      ip,
+    });
+
+    reson({ message: 'Contraseña actualizada exitosamente.' });
+  } catch (error) {
+    next(error);
+  }
+};
+
+export const eliminarUsuario = async (req, res, next) => {
+  try {
+    const { id } = req.params;
+    const usuario = await Usuario.findByPk(id);
+    console.log('Usuario encontrado:', usuario);
+    if (!usuario) {
+      return res.status(404)on({ message: 'Usuario no encontrado' });
+    }
+
+    const ip = req.headers['x-forwarded-for'] || req.socket?.remoteAddress || null;
+    console.log('IP del usuario:', ip);
+    await usuario.destroy();
+
+    await crearAuditoria({
+      tabla: 'usuarios',
+      accion: 'elimina usuario',
+      registroId: usuario.id,
+      usuarioId: req.usuario?.id || null,
+      descripcion: `Se eliminó el usuario "${usuario.nombre}"`,
+      ip,
+    });
+
+    reson({ message: 'Usuario eliminado' });
+  } catch (error) {
+    console.error('❌ Error al eliminar usuario:', error);
+    next(error);
+  }
+};
\ No newline at end of file
diff --git a/backend-nest/src/usuario/usuario.model.ts b/backend-nest/src/usuario/usuario.model.ts
new file mode 100755
index 0000000000000000000000000000000000000000..d3e27ab2c3cb9319aae0efcf12b240e5f5b1953f
--- /dev/null
+++ b/backend-nest/src/usuario/usuario.model.ts
@@ -0,0 +1,60 @@
+import { nanoid } from 'nanoid';
+import { ROLES_USUARIOS } from '../constants/rolesUsuarios.js';
+
+export default (sequelize, DataTypes) => {
+  const Usuario = sequelize.define('Usuario', {
+    nombre: {
+      type: DataTypes.STRING,
+      allowNull: false,
+    },
+    email: {
+      type: DataTypes.STRING,
+      allowNull: false,
+      unique: true,
+    },
+    contraseña: {
+      type: DataTypes.STRING,
+      allowNull: true, // puede ser null en el primer login
+    },
+    rolUsuarioId: {
+      type: DataTypes.INTEGER.UNSIGNED,
+      allowNull: false,
+    },
+    link: {
+      type: DataTypes.STRING(4),
+      allowNull: true,
+      unique: true,
+    },
+    telefono: {
+      type: DataTypes.STRING,
+      allowNull: true,
+    },
+    createdAt: DataTypes.DATE,
+    updatedAt: DataTypes.DATE,
+    deletedAt: DataTypes.DATE,
+  }, {
+    tableName: 'Usuarios',
+    timestamps: true,
+    paranoid: true,
+  });
+
+  // 🔁 Hook para asignar link corto si es VENDEDOR
+  Usuario.beforeCreate((usuario) => {
+    if (usuario.rolUsuarioId === ROLES_USUARIOS.VENDEDOR) {
+      usuario.link = nanoid(4).toUpperCase();
+    }
+  });
+
+  Usuario.associate = (models) => {
+    Usuario.hasMany(models.Pedido, { foreignKey: 'usuarioId' });
+    Usuario.hasMany(models.Cliente, { foreignKey: 'vendedorId' });
+    Usuario.hasMany(models.LogAuditoria, { foreignKey: 'usuarioId' });
+
+    Usuario.belongsTo(models.RolUsuario, {
+      foreignKey: 'rolUsuarioId',
+      as: 'rolUsuario',
+    });
+  };
+
+  return Usuario;
+};
diff --git a/backend-nest/tsconfig.build.json b/backend-nest/tsconfig.build.json
new file mode 100644
index 0000000000000000000000000000000000000000..5e9cfea242f8b8b1249158fc1f19e821b7e0ae93
--- /dev/null
+++ b/backend-nest/tsconfig.build.json
@@ -0,0 +1,8 @@
+{
+  "extends": "./tsconfig.json",
+  "compilerOptions": {
+    "outDir": "dist"
+  },
+  "include": ["src/**/*.ts"],
+  "exclude": ["node_modules"]
+}
diff --git a/backend-nest/tsconfig.json b/backend-nest/tsconfig.json
new file mode 100644
index 0000000000000000000000000000000000000000..d9300ebfd2cabe2e723c7e2c37aeaa12d5a612f1
--- /dev/null
+++ b/backend-nest/tsconfig.json
@@ -0,0 +1,28 @@
+{
+  "compilerOptions": {
+    "module": "CommonJS",
+    "target": "ES2019",
+    "lib": ["ES2019"],
+    "moduleResolution": "node",
+    "outDir": "dist",
+    "rootDir": "src",
+    "experimentalDecorators": true,
+    "emitDecoratorMetadata": true,
+    "strict": true,
+    "esModuleInterop": true,
+    "baseUrl": "src",
+    "paths": {
+      "@/*": ["*"],
+      "@models": ["models"],
+      "@utils/*": ["utils/*"],
+      "@services/*": ["services/*"],
+      "@helpers/*": ["helpers/*"],
+      "@state/*": ["state/*"],
+      "@constants/*": ["constants/*"],
+      "@middlewares/*": ["middlewares/*"],
+      "@validaciones/*": ["validaciones/*"]
+    }
+  },
+  "include": ["src/**/*.ts"],
+  "exclude": ["node_modules"]
+}

